<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
<!--    <link rel="stylesheet" href="style.css"> -->
    <title>MACXX</title>
  <style>
  table {
    border-collapse: collapse;
    width: 50%;
  }
  
  th, td {
    text-align: left;
    padding: 2px;
  }
  
  tr:nth-child(even) {
    background-color: #D6EEEE;
  }
  .TblCntr table
  {
		margin: 10px;
		border:1px solid #000;
    border-collapse: collapse;
    width: 50%;
    align: left;
  }
  .TblCntr tr
  {
    border: 2px solid white;
  }
  .TblCntr th
  {
    border: 2px solid white;
    text-align: center;
    padding: 2px;
  }
  .TblCntr td
  {
    border: 2px solid white;
    text-align: center;
    padding: 2px;
  }
  .TblCntr tr:nth-child(even)
  {
      background-color: #D6EEEE;
  }
  </style>
  </head>
  <body>
  <div style="width: 25%;text-align:center;">
  <h1>MACXX</h1>
  MACxx Macro Assembler<br>
  Version 10.28<br>
  First created probably late 1977<br>
  Revisions through Nov 1989 on the PDP11 assembly version<br>
  Revisions through Aug 2022	on the C version<br>
  </div>
  <p></p>
  <div style="border: 2px solid black;margin:4px;padding: 4px">
  <em>Note from Dave Shepperd, 8/2022
  <p>
  There never were any release notes kept on this application so there is no record of what got changed when. It just is what it is.
  I wrote the PDP11/RT11 version in the late 1970's and the current C version in the early to mid 1980's. It continued to get development until the late 1990's
    and continues to get bug fixes and new features to this day.
    </p>
    <p>
    Recently I got involved in rebuilding some of old Atari coin-op game code (some of which recently
    was released on github) and wanted to use this tool to make ROM/EPROM images and to test them with MAME. This prompted me to port the documentation,
    what little there is, of the three main applications used to build game images to HTML. Those tools are the assembler
    (<a href="https://github.com/DaveShepperd/macxx.git" target="_blank">MACXX</a>),
    linker (<a href="https://github.com/DaveShepperd/llf.git" target="_blank">LLF</a>) and rom image maker
    (<a href="https://github.com/DaveShepperd/mixit.git" target="_blank">MIXIT</a>).
    Although I wrote the original documentation for this assembler (macxx.doc which was the basis for this document), I am neither a technical
    writer nor am I any good at HTML5. As might be evidenced
    with the original documentation, I quickly lose interest in writing technical documents and don't check things too closely. So good luck
    making sense of anything written here. Feel free to hack this document into something more readable. If you do, please send me a copy.
  </p>
    <p>If one cares, I wrote a little history about how this assembler and the other two tools came to be. It can be found
    <a href="#history">HERE</a>.
    </p>
  </em>
  </div>
  <p>
  MACxx is an assembler first written in PDP11 assembly language for a computer running RT11 (RT11 version 2 or 3, I don't recall which).
  Later it was rewritten in the C language and has been ported to various operating systems. The RT11 version was implemented as a 2 pass
  assembler. The current C version is a 1.5 pass assembler meaning it makes one pass through the source code producing both a listing and
  an intermediate internally maintained binary object "file". Once all the souce has been parsed, it makes another pass through its internally
  maintained object "file" resolving all expressions it is able to and producing the actual binary or ASCII object file. As of version 11.??
  a new command line -option of -2_PASS can be used to force the assembler to run in a full 2 pass mode. But that option is only available for mac65,
  mac68 and mac69.
  </p>
  <p> The macxx sources produce a unique macro assembler for the following processors:
  </p>
  <pre>
  <b>macpp</b>    - A macro pre-processor; no CPU; it works similar to the C language's CPP.
  <b>mac65</b>    - For the MOS Technology 6502, 65C02 and 65816 CPU's
  <b>mac68</b>    - For the Motorola 6800 CPU
  <b>mac69</b>    - For the Motorola 6809 CPU
  <b>mac68k</b>   - For the Motorola 68000 and 68010 CPU
  <b>mac11</b>    - For the PDP11 CPU
  <b>macas</b>    - For the custom Atari Simplified Architecure Processor (ASAP) CPU
  <b>mactj</b>    - For the Atari custom Tom and Jerry DSP's
  </pre>
  <p>
  <b>Macxx</b> consists of a core group of pseudo-ops
  common among all versions of the assembler and a common statement syntax. The output of these assemblers
  (except <b>MACPP</b>) is expected to be further processed by <b>LLF</b> into a load image. <b>LLF</b> is
  yet another tool I wrote that is a link+locate+format editor. <b>LLF</b> may be found <a href="https://github.com/DaveShepperd/llf.git" target="_blank">HERE</a>.
  </p>
  <p><em>NOTE: There may be some obscure bug in these sources somewhere where if you build it as a 64 bit application, it
  makes some obscure mistake. I'm not sure about this, I've only heard about it from someone who complained. I haven't
  looked into it further. It was just too easy to build with -m32 and forget about it. User beware.
  </em>
  </p>
  <h2>Table of contents</h2>
  <table style="width: 35%">
<!--    <tr><th>Valid symbols</th><th>Invalid symbols</th></tr> -->
    <tr><td><a href="#gen_syntax">Statement syntax</a></td><td></td>
    <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
    <tr><td><a href="#dir_byte">DC.x</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_blkx">DS.x</a></td><td>Allocation storage</td>
    <tr><td><a href="#dir_globl">XDEF, XREF</a></td><td>Assign symbol(s) as being global in scope</td>
    <tr><td><a href="#dir_byte">.ADDRESS</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_align">.ALIGN</a></td><td>Align location counter</td>
    <tr><td><a href="#dir_ascix">.ASCII, .ASCIN, .ASCIZ</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_psect">.ASECT, .BSECT, .CSECT</a></td><td>Set program section</td>
    <tr><td><a href="#dir_blkx">.BLKx</a></td><td>Allocation of storage</td>
    <tr><td><a href="#dir_byte">.BYTE, .WORD, .LONG</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_cpu">.CPU</a></td><td>65816 specific instruction</td>
    <tr><td><a href="#dir_define">.DEFINE, .UNDEFINE</a></td><td>Define/Undefine some replacement text</td>
    <tr><td><a href="#dir_defstack">.DEFSTACK</a></td><td>Define a user stack</td>
    <tr><td><a href="#dir_dpage">.DPAGE</a></td><td>65816 specific instruction</td>
    <tr><td><a href="#dir_enabl">.ENABL, .DSABL</a></td><td>Enable/Disable assembler functions</td>
    <tr><td><a href="#dir_end">.END</a></td><td>End of assembly</td>
    <tr><td><a href="#dir_endm">.ENDM</a></td><td>End of macro</td>
    <tr><td><a href="#dir_endm">.ENDR</a></td><td>End of indefinite repeat blocks</td>
    <tr><td><a href="#dir_endc">.ENDC</a></td><td>End of conditional assembly block</td>
    <tr><td><a href="#dir_error">.ERROR</a></td><td>Signal an assembly error</td>
    <tr><td><a href="#dir_escape">.ESCAPE</a></td><td>Set various escape characters</td>
    <tr><td><a href="#dir_even">.EVEN</a></td><td>Align location counter</td>
    <tr><td><a href="#dir_float">.FLOAT</a></td><td>Tom&Jerry specific instruction</td>
    <tr><td><a href="#dir_getpointer">.GETPOINTER</a></td><td>Get a user's stack pointer</td>
    <tr><td><a href="#dir_globl">.GLOBx</a></td><td>Assign symbol(s) as being global in scope</td>
    <tr><td><a href="#dir_if">.IF, .IFx, .IIF</a></td><td>Conditional assembly</td>
    <tr><td><a href="#dir_include">.INCLUDE</a></td><td>Include another file during assembly starting with this line</td>
    <tr><td><a href="#dir_irp">.IRP, .IRPC</a></td><td>Indefinite repeat blocks</td>
    <tr><td><a href="#dir_ldlit">.LDLIT</a></td><td>ASAP specific instruction</td>
    <tr><td><a href="#dir_length">.LENGTH</a></td><td>Set length of symbol, opcode or MAU</td>
    <tr><td><a href="#dir_list">.LIST, .NLIST</a></td><td>Enable/Disable listing controls</td>
    <tr><td><a href="#dir_byte">.LONG</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_macro">.MACRO</a></td><td>Macro definition</td>
    <tr><td><a href="#dir_byte">.MAU, .2MAU, .4MAU</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_mexit">.MEXIT</a></td><td>Macro exit</td>
    <tr><td><a href="#dir_narg">.NARG</a></td><td>Get number of macro arguments</td>
    <tr><td><a href="#dir_nchr">.NCHR</a></td><td>Get number of characters in string</td>
    <tr><td><a href="#dir_list">.NLIST</a></td><td>Disable listing controls</td>
    <tr><td><a href="#dir_even">.ODD</a></td><td>Align location counter</td>
    <tr><td><a href="#dir_outfile">.OUTFILE</a></td><td>Change output file (MACPP only)</td>
    <tr><td><a href="#dir_page">.PAGE</a></td><td>Put form feed in listing</td>
    <tr><td><a href="#dir_pop">.POP</a></td><td>Pop a value from a user stack</td>
    <tr><td><a href="#dir_print">.PRINT</a></td><td>Print text on line printer output</td>
    <tr><td><a href="#dir_psect">.PSECT</a></td><td>Set program section</td>
    <tr><td><a href="#dir_push">.PUSH</a></td><td>Push an expression onto a user stack</td>
    <tr><td><a href="#dir_radix">.RADIX</a></td><td>Set number interpreter radix</td>
    <tr><td><a href="#dir_restore">.RESTORE</a></td><td>Restore location counter from a previous .SAVE</td>
    <tr><td><a href="#dir_rept">.REPT</a></td><td>Repeat block</td>
    <tr><td><a href="#dir_rexit">.REXIT</a></td><td>Repeat block exit</td>
    <tr><td><a href="#dir_save">.SAVE</a></td><td>Save the current location counter</td>
    <tr><td><a href="#dir_sbttl">.SBTTL</a></td><td>Set a subtitle</td>
    <tr><td><a href="#dir_setpointer">.SETPOINTER</a></td><td>Set the user stack's pointer</td>
    <tr><td><a href="#dir_sbttl">.SUBTITLE</a></td><td>Set a subtitle</td>
    <tr><td><a href="#dir_stabx">.STABx</a></td><td>Pass stab debug directives through to object file</td>
    <tr><td><a href="#dir_ascix">.STRING</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_globl">.STATIC</a></td><td>Assign symbol(s) as being static in scope</td>
    <tr><td><a href="#dir_test">.TEST</a></td><td>Perform a test on an expression</td>
    <tr><td><a href="#dir_title">.TITLE</a></td><td>Set the title for the pages in the listings</td>
    <tr><td><a href="#dir_triplet">.TRIPLET</a></td><td>MAC65 only; Put 24 bit variables in memory</td>
    <tr><td><a href="#dir_undefine">.UNDEFINE</a></td><td>Undefine some replacement text</td>
    <tr><td><a href="#dir_vctrs">.VCTRS</a></td><td>Place 15 bit vectors in the object file</td>
    <tr><td><a href="#dir_warn">.WARN</a></td><td>Signal an assembly warning</td>
    <tr><td><a href="#dir_byte">.WORD</a></td><td>Put constants in memory</td>
    <tr><td><a href="#dir_globl">xref, xref.s</a></td><td>Assign symbol(s) as being global in scope</td>
    <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
    <tr><td><a href="#gen_macros">Macros</a></td><td>How to use macros</td>
    <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
    <tr><td><a href="#gen_operating">Operating MACXX</a></td><td>How to run MACXX</td>
    <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
    <tr><td><a href="#history">History</a></td><td>A bit of history</td>
  </table>
  <h2 id="gen_syntax">Statement syntax</h2>
  <p>
  A source program is composed of a sequence of source lines; each 
  source line contains a single assembly language statement followed by a 
  terminator (line feed or form feed). Input lines are limited to 255
  characters.
  </p>
  <p>
  A statement can contain up to four fields which are identified by order
  of appearance and by specified terminating characters. The general 
  format of a MACxx assembly statement is:
  </p>
  <pre>
      [label:]	[opcode	[operand(s)]]	[;comments]
  </pre>
  <p>
  Items shown surrounded with []'s are optional.
  The label is delimited by one or two
  colon characters (:) and the semicolon (;) delimits the comments. White space
  may be required to delimit the opcode from the operand and multiple
  operands may need either a comma (,) or white space to delimit them from
  one another but otherwise, white space is optional. 
  </p>
  <h3 id="gen_label">Label field</h3>
  <p>
  A label is a user defined symbol that is unique to the first n characters
  (various assemblers have various defaults for 'n' but the value for 'n'
  may be changed to any number up to 32 with a command line option or asssembler
  directive) and is 
  assigned to the value of the current location counter and entered into 
  the user symbol table (as opposed to the 'permanent' symbol table). The 
  value may be either absolute (fixed at a specific location in memory at 
  assembly time) or relocatable (fixed at a specific location at link or 
  load time). This depends on whether the current section is absolute or 
  relocatable. A label is a symbolic method of referring to a specific place
  in memory. If present, a label must be first in the statement and 
  terminated with a colon. For example:
  </p>
  <pre>
      FRED:	LDA FOOBAR
  </pre>
  <p>
  defines FRED to point to the location in memory of the LDA instruction.
  More than one label can appear on a single statement, however, each 
  will be given the same value. For example:
  </p>
  <pre>
      ONE: TWO: THREE: LDA FOOBAR
  </pre>
  <p>
  defines ONE, TWO and THREE to point to the location in memory of the LDA 
  instruction. A symbol used as a label may not be redefined and any 
  attempt to do so will result in an error message. If two colon 
  characters are used to delimit the label, then the label is defined 
  as a global. Global labels are inserted into the object file so that
  LLF and, subsequently, other modules will be able to reference them
  by name. For example:
  </p>
  <pre>
      FRED::	LDA FOOBAR	;fred is defined and also made global
  </pre>
  <p>  
  Internal symbols may belong to the current program section or to other
  program sections. Expressions containing symbols belonging to different
  program sections may not be completely resolved by the assembler.
  Depending on the type of operation that is required in the expression,
  it may not be possible for the assembler to resolve an expression
  regardless of which section a symbol belongs. In these cases, the
  expression will be passed to the separate <b>LLF</b> (custom Link+Locate+Format)
  program to be resolved after all the sections
  have been relocated and labels defined to their ultimate values.
  </p>
  <h3 id="gen_opcode">Opcode field</h3>
  <p>
  The opcode field contains an opcode, macro name or assembler directive
  (pseudo-op). Is is legally terminated by white space or any 
  non-alphanumeric character. For example:
  </p>
  <pre>
      LDA #FRED	;the white space delimits the opcode
      LDA#FRED	;the # delimits the opcode
  </pre>
  <h3 id="gen_operands">Operand field</h3>
  <p>
  The operand field contains zero, one or more items that may be separated
  by commas or white space depending on the requirements of the opcode,
  macro or pseudo-op. The operand field is terminated by the semicolon of
  an optional comment or an end-of-line. For example: 
  </p>
  <pre>
      CLC          ;no operands are required
      LDA FRED     ;FRED is the operand
      LDA FRED,X   ;FRED and X are operands to the LDA opcode
  </pre>
  <h3 id="gen_comments">Comment field</h3>
  <p>
  The comment field is optional and may contain any printing ASCII 
  character as well as tab and space. All other non-printing ASCII 
  characters except new-line will be converted to white space. The 
  comment begins with a semicolon (;) which may appear anywhere on the
  line and continues to end-of-line. The contents of comments are
  ignored by the assembler.
  </p>
  <h3 id="gen_formatting">Formatting</h3>
  <p>
  Spaces, tabs and form feeds may be used at will to control the text 
  formatting in the source file. A form feed character is interpreted as 
  a new line. Except in certain contexts (such as ASCII constants and
  parameter delimiting) white space is ignored by the assembler.
  </p>
  <h4>Symbols</h4>
  <p>
  Assembler symbols, labels and macro names can be comprised of any of the
  letters A through Z (upper and/or lower case), digits 0 through 9,
  period (.), dollar sign ($) and underscore (_). The first character of a
  symbol or label must not be a digit except in the special case of local symbols
  described HERE. The case of the letters in a symbol
  is not significant unless the .ENABL LOWER option has been selected. For
  example: 
  </p>
  <table class="TblCntr" style="width: 20%">
    <tr><th>Valid symbols</th><th>Invalid symbols</th></tr>
    <tr><td>ABC</td><td>0123</td></tr>
    <tr><td>abc</td><td>2abc</td></tr>
    <tr><td>$._AB_C.$$</td><td>9$AB_.</td></tr>
  </table>
  <p>
  The symbol length is, by default, significant to the first 'n' characters
  only. The default value for 'n' varies from assmbler to assembler however
  it may be changed via a command line option or an assembler directive.
  In either case the significant length cannot be
  reduced to less than 6 nor made greater then 32. Symbols output in the
  object file will be uppercased (unless the .ENABL LOWER option has been
  selected; its default varies from assembler to assembler) and truncated
  to the significant length. Symbols are delimited
  by any character that is not included in the list of valid symbol
  characters. Be advised that not all load file formats accept symbol names
  as long as 32 characters. Extended TEKhex, for example, will only pass 
  the first 16 characters of a symbol name. This will only be a 
  significant factor if one intends on passing global symbols with long 
  names to a symbolic debugger via a restricting load file format.
  </p>
  <h4>Permanent symbols</h4>
  <p>
  Permanent symbols are those pre-defined in the assembler and consist
  entirely of opcodes and pseudo-ops. The assembler allocates memory from
  the operating system and "seeds" this area with the permanent symbols
  stored internal to the assembler. Macro names that are defined by the
  user are placed into the permanent symbol table perhaps replacing an
  existing entry. 
  </p>
  <h4>User defined symbols</h4>
  <p>
  User symbols both ordinary and local are stored in a user symbol table.
  This symbol table is the only one searched during expression evaluation.
  The permanent symbol table is the only one searched for opcodes.
  Consequently, macro and opcode names may be the same as symbol and label
  names and each represents different values. 
  </p>
  <p>
  User defined symbols are either internal or external (global). All user 
  defined symbols are internal unless explicitly declared otherwise.
  </p>
  <p>
  <b>MAC68K</b> and <b>MACAS</b> have predefined user symbols representing the standard 
  register names found in those processors. See the appendix for specifics.
  </p>
  <h4 id="gen_localSymbols">Local symbols</h4>
  <p>
  There's a special type of symbol known as a local symbol. This symbol 
  is a string of decimal digits terminated with a dollar sign. Its 
  presence is known only within what is known as a local symbol block (LSB).
  The LSB is delimited, unless otherwise indicated, with
  changes in program sections or by the definition of a new label.
  Local symbols can be used anywhere ordinary symbols can be used and are
  defined the same as ordinary symbols. They cannot, however, be declared
  global. Local symbols must consist only of the digits 0-9 and a 
  trailing dollar sign, but otherwise they are treated as ordinary strings 
  and are limited in length to the maximum input size of 255 characters.
  Some examples:
  </p>
  <pre>
      lsb_1:       ;Any label starts a new local symbol block
      10$:         ;defines local symbol 10$
      20$ = fred   ;direct assignments work too,...
      LABEL = fred ;  ...however, direct assignments do NOT open a new LSB
      30$:         ;another local label
      lsb_2:       ;Opens a new LSB
      10$:         ;these local symbols are not the same as
      20$:         ;  the other ones because they are in a
      30$:         ;    different LSB.
      .PSECT       ;this opens a new local symbol block too
  </pre>
  <p>
  There may be instances where one needs to reference local symbols 
  across ordinary labels or through program section changes. This can be 
  accomplished with a pseudo-op:
  </p>
  <pre>
      .ENABL LSB    ;opens a LSB and turns OFF
                    ; the normal lsb delimiter sensing.
      10$:          ;defines a local symbol
      LABEL:        ;in this case, does NOT open a new lsb
      .WORD 10$     ;refers to the 10$ above LABEL
      .DSABL LSB    ;closes the LSB and turns back ON
                    ;  then normal lsb delimiter sensing.
  </pre>
  <h4>Location counter symbol</h4>
  <p>
  There's a special pre-defined symbol, period (.), that refers to
  the current location counter. The value of this symbol is always defined
  and may be relocatable or absolute depending on the attribute of the
  current section. The period may not be used as a label. It may only be
  used in expressions and as the target of a direct assignment statement. 
  For example:
  </p>
  <pre>
      saved_place = .     ;saves current location
      . = some_new_place  ;set the current location to new place
      offset = <.+3>/4    ;compute displacement
  </pre>
  <p>
  Care must be used when making direct assignments to the location counter 
  or there will certainly be unexpected results. For example, there are 
  times when one wants to position the location counter to a fixed 
  location from the beginning of a RELOCATABLE program section. This 
  CANNOT be done by simply assigning the location counter to the offset.
  Suppose one wants to set the location counter to an offset of 1000 from 
  the start of section DATA. First a symbol would have to be defined at
  the beginning of the DATA section:
  </p>
  <pre>
    .PSECT DATA             ;declare section DATA
    START_OF_DATA:          ;define first location of section DATA
  </pre>
  <p>  
  Then the location counter can be set:
  </p>
  <pre>
    . = START_OF_DATA+1000   ;move PC to DATA+1000.
  </pre>
  <p>  
  The more direct approach of .=1000 is only allowed when the current
  location is an absolute (non-relocatable) section. Direct assignments
  that would result in having the current section change are not allowed
  and will result in an error message. For example:
  </p>
  <pre>
      .PSECT TEXT
      FRED:
      .PSECT DATA
      . = FRED	;will result in an error since FRED
                ;   is not in the DATA psect
  </pre>
  </p>  
  <!-- Does not work so just don't tell anybody about it
  <h4>Symbol blocks</h4>
  <p>
  Another form of local symbol block exists which allows for all forms of 
  symbols to appear "local to the block". That is, symbols and labels
  defined within a symbol block can only be referenced by code and data 
  appearing within that block or a fully enclosed block. These blocks can 
  be nested to a depth of 7. Nested levels beyond 7 are folded into 
  level 7 and a warning message stating that the scoping is too deep is 
  displayed. Inner blocks may reference symbols and labels defined in an 
  outer block, but outer blocks may not reference symbols and labels 
  defined in inner blocks. The outer most level is 0 and is the level 
  used by normal symbols and labels. There are a maximum of 8192 blocks 
  available in a single assembly module. This block is delimited between
        the psuedo ops .PROC and .ENDP. For example:
  </p>
        <pre>
          .PROC        ;This opens a local symbol block
          FRED:        ;This defines a local version of FRED
          FOOBAR = 123 ;It works for both labels and symbols
          .WORD FRED   ;The symbol can be used in the block
          .ENDP
          .WORD FRED   ;This will produce an error since FRED is unknown
          .WORD FOOBAR ;This will error out too
        </pre>
  <p>
  WHEN USING SYMBOL BLOCKS, FORWARD REFERENCES TO SYMBOLS OR LABELS ARE
  NOT ALLOWED. All symbols and labels referenced in the current block must
  be predefined or predeclared. There is a .LOCAL directive to declare a
  symbol and/or label in a block if it is referenced before it is defined. 
  </p>
  -->
  <h4>Radix</h4>
  <p>
  The programmer can specify the radix with which a number is to be
  interpreted on each number appearing in the source or globally for all
  numbers appearing in the source. The radix values can be one of 2,8,10
  or 16. Using the .RADIX pseudo-op specifies which radix to use for all
  numbers appearing between that directive and the next .RADIX or end of
  file. The unary operators ^B, ^O, ^D (or trailing period), ^X or ^H
  can be used on individual numbers to indicate the radices 2, 8, 10, 16
  or 16 respectively. In addition, hexadecimal numbers may be expressed by
  prefixing a "0x" or "0X" to them. 
  </p>
  <h4>Numbers</h4>
  <p>
  Number constants are strings consisting of the digits 0-9 and the
  letters A-F. The first character of the number must be a digit 0-9
  regardless of the current radix. Any character not of that character set
  delimits the number. If the number contains digits that are greater than
  the current radix allows, the assembler will attempt to evaluate the
  number at the appropriate higher radix and displays an error message. A
  temporary decimal radix can be set by appending a period to the number
  or any other temporary radix can be set via a one of the unary operators
  (^B, ^D, ^O, ^X or ^H for binary, decimal, octal, hex or hex respectively).
  For example: 
  </p>
        <pre>
      0110     ;valid binary, octal, decimal or hex number
      1234     ;valid octal, decimal or hexadecimal number
      7890     ;valid decimal or hexadecimal number
      0FFF     ;valid hex number
      A000     ;not a valid number (valid symbol, though)
      1000.    ;decimal 1000
      0x1234   ;hexadecimal number
      ^X 1234  ;hexadecimal number
        </pre>
  
  <h3 id="gen_expressions">Expressions</h3>
  <p>
  An expression is a collection of one or more terms separated by
  arithmetic operators. There are both unary operators (apply only to a
  single term) and binary operators (apply to two terms). Unlike most
  other languages, all operators have equal precedence and are evaluated
  from left to right. The order of evaluation can be changed by the use of
  the parenthesis. (In MAC65, the parenthesis must be substituted with the
  expression brackets "<" and ">"). All terms in an expression and the
  result of the expression itself are 32 bits (signed). The relational
  operators (not available in MAC65) return either a 0 for false or 1 for
  true. 
  </p>
  <table style="width: 30%">
    <tr><th>Binary operators</th><th>Examples</th><th>Meaning</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+</td><td>A+B</td><td>A added with B (can also be +A which means 0+A)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-</td><td>A-B</td><td>A subtracted with B (can also be -A which means 0-A)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*</td><td>A*B</td><td>A multiplied by B (32 bit product)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</td><td>A/B</td><td>A divided by B (returns a 32 bit quotient)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&</td><td>A&B</td><td>A logically anded with B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td><td>A|B</td><td>A logically or'ed with B</td></tr>
  </table>
  <p>    
  The following are <u><b>NOT</b></u> available in MAC65 but are available in all the others:
  </p>
  <table style="width: 30%"> 
    <tr><th>Binary operators</th><th>Examples</th><th>Meaning</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</td><td>A^B</td><td>A exclusive or'ed with B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;</td><td>A&lt;&lt;B</td><td>A shifted B bits left</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;</td><td>A&gt;&gt;B</td><td>A shifted B bits right</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==</td><td>A==B</td><td>returns 1 if A equals B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!=</td><td>A!=B</td><td>returns 1 if A not equal B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;</td><td>A&gt;B</td><td>returns 1 if A greater than B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;</td><td>A&lt;B</td><td>returns 1 if A less than B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;=</td><td>A&gt;=B</td><td>returns 1 if A greater than or equal to B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;=</td><td>A&lt;=B</td><td>returns	1 if A less than or equal to B</td></tr>
  </table>
  <p>
  The following are available <u><b>ONLY</b></u> in MAC65 (this was chosen to keep compatible with the syntax of the very old PDP11 version of MAC65):
  </p>
  <table style="width: 30%">
    <tr><th>Binary operators</th><th>Examples</th><th>Meaning</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!</td><td>A!B</td><td>A logically or'ed with B (same as |)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?</td><td>A?B</td><td>A exclusive or'ed with B (same as ^ in other assemblers)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</td><td>A{B</td><td>A is shifted B bits left (same as &lt;&lt; in other assemblers)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</td><td>A}B</td><td>A is shifted B bits right (same as &gt;&gt; in other assemblers)</td></tr>
  </table>
  <p>
  Unary operators are escaped with a circumflex (^) which means the character 
  following the circumflex is the operator. In order for this to be noticed and not confused with the exclusive or
    binary operator, the circumlex must appear as the first character of a term. But one would be wise to watch
    for any potential confusion in this regard. I.E. A^^^B looks confusing, but it means exclusive or A with the high
    byte of B.
  </p>
  <table style="width: 30%">
    <tr><th>Unary operators</th><th>Examples</th><th>Meaning</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^C</td><td>^C A</td><td>returns 1's compliment of A</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^B</td><td>^B 100</td><td>change radix of term to  2 (binary; number is 0x004)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^D</td><td>^D 100</td><td>change radix of term to 10 (decimal; number is 0x064)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^H</td><td>^H 100</td><td>change radix of term to 16 (hexadecimal; number is 0x100)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^O</td><td>^O 100</td><td>change radix of term to  8 (octal; number is 0x40)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^X</td><td>^X 100</td><td>change radix of term to 16 (hexadecimal; number is 0x100)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^V</td><td>^V A</td><td>returns low byte: bits 7-0 of A</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^</td><td>^^ A</td><td>returns high byte: bits 15-8 of A</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^~</td><td>^~ A</td><td>returns bits 15:8 swapped with bits 7:0 and bits 23-16 with bits 31-24 of A</td></tr>
  </table>  
    <p>
  Any term of an expression may be enclosed in a pair of expression
  brackets ('&lt;' and '&gt;' in MAC65 or '(' and ')' in all other assemblers)
  and itself be a collection of one or more terms. For example: 
  </p>
    <pre>
      A+&lt;&lt;B*C/D+6&gt;*100&gt;/4?^V&lt;FRED*10&gt;+^H&lt;0FFF+ABC+1234&gt; ;MAC65
      A+((B*C/D+6)*100)/4^^V(FRED*10)+^H(0FFF+ABC+1234) ;others
    </pre>
  <p>
  would evaluate in the following order (left to right, all operators having
  equal precedence):
  </p>
    <pre>
      B*C/D+6*100+A/4 exclusive OR'd with the low byte of FRED*10
      and the whole result added to ABC+0x2233
    </pre>
  
  <h4>Direct assignment</h4>
  <p>
  A direct assignment statement associates a symbol with a value (or an
  expression). When a direct assignment statement is used for the first 
  time that symbol is entered into the user defined symbol table and the 
  specified value is attached to it. If the expression does not resolve 
  to an absolute value, then the expression is attached to the symbol. A 
  symbol may be re-defined by assigning a new value to it. The latest 
  assigned value replaces any previous value assigned to the symbol.
  The general format is:
  </p>
    <pre>
      symbol = expression	;comments
    </pre>
  <p>  
  Symbols take on the relocatable or absolute attributes of their defining
  expression. If the expression does not resolve to a single term then the
  resultant expression is attached to the symbol and the value of the
  symbol becomes a multiple term expression which will be substituted in
  whatever other expressions the symbol is used and, in fact, may be
  passed on to LLF if it cannot be resolved during object file creation. A
  double equal sign will declare the symbol global as well as defining it,
  however, for purposes of linking, only the last assignment made to a
  symbol is passed to LLF (i.e. the value at the end of pass one of the
  assembler is what gets passed to LLF). One may prefix a colon to the
  equals or double equals to indicate that the symbol is to be defined
  only once (i.e. generate an error if the symbol is redefined elsewhere).
  For example: 
  </p>
    <pre>
      A = 1      ;A has absolute value of 1
      B:         ;defines B as a relocatable
      C = B      ;C is equivalent to B
      D = E+F+G  ;If E, F or G is undefined or relocatable then
                 ;  D becomes defined as E+F+G (expression)
      H == 12    ;H is global 12
      . = .+100  ;move the location counter up 100 bytes
      J := 10    ;make J an absolute 10 and not eligible for 
                 ;  redefinition
    </pre>
  <p>
    <b>DO NOT MAKE CIRCULAR ASSIGNMENTS SUCH AS</b>
    </p>
    <pre>
        A = B
        B = C
        C = A
    </pre>
  
  <h4>Register symbols and expressions</h4>
  <p>
  Some assemblers (such as MAC11, MACAS, MAC68K, MAC682K) may have opcodes that allow
  or require registers as operands. They may, in fact, sense the type of
  operand and output object data differently based on whether there is a
  register referenced in the operand. Any valid expression term with a
  leading percent sign (%) declares that term as a register (for example
  %5 means register 5). Symbols can be defined as being register
  designators by assigning them to an expression with one or more of the
  terms being a register term. The symbol will inherit the register
  attribute from the expression. For example: 
  </p>
    <pre>
      R0 = %0       ;general register 0
      R10 = %10.    ;general register 10
      TEMP = R0     ;symbol TEMP becomes equivalent to R0
      GR11 == %11.  ;global general register 11
    </pre>
  <p>
  Register symbols can be global and can even be defined in other modules.
  Global register symbols used but not defined in a given module must be
  declared with the .GLOBR pseudo-op. The register attribute of a symbol
  is only significant during the operand processing of an opcode. The
  register attribute of a symbol is not significant in any other assembler
  expression. The register attribute is ignored in MAC65. Undefined registers
  are not allowed in MAC68K. See the appendix for a list of pre-defined
  register symbols for the assembler you are using. 
    </p>
  <h2>Assembler Directives</h2>
  <p>  
  Assembler directives, aka pseudo-ops, are statements that the 
  assembler intreprets as commands to itself. Directives control various 
  aspects of the assembler behavior and output.
    </p>
  <h3 id="dir_align">.ALIGN</h3>
    <pre>
    .ALIGN [expression]
    </pre>
    <p>
  where expression must resolve to an absolute between the values 0 and 31
  inclusive (defaults to 0 or, in effect, a nop). The value of expression becomes an exponent of 2 and the location
  counter is adjusted to the next multiple of the result. The alignment
  attributes of the current program section must enforce an alignment at least
  as great as the one requested or a warning message will be displayed.
  If the alignment attributes of the current section do not enforce an
  alignment as great as the one requested, then do not expect the resultant
  location after linking (LLF) to be correct. Some examples:
  </p>
    <pre>
      .ALIGN 3    ;aligns to next multiple of 8 bytes
      .ALIGN 0    ;aligns to next byte (effectively a nop)
      .ALIGN 1    ;aligns to 2 byte boundary
      .ALIGN fred ;aligns to whatever FRED resolves to
    </pre>
  <h3 id="dir_ascix">.ASCII, .ASCIIZ, .ASCIN and .STRING</h3>
    <pre>
      .ASCII [string]
      .ASCIN [string]
      .ASCIZ [string]
      .STRING [string]  ;Same as .ASCIZ
    </pre>
  <p>  
  Deposits a string of ASCII characters beginning at the current location.
  The parameter string consists of a string of ASCII characters delimited
  by a pair of ASCII characters. The first character in the string is assumed
  the delimiter for the string. The delimiters are not considered part of the
  string so are not inserted into the output file. Any printing character can
  be a delimiter. Expressions can be inserted in the middle of the string by
  delimiting the string and enclosing the expression in matching expression
  brackets (&lt;&gt;'s in MAC65, ()'s in the other assemblers). Ths general 
  format is:
  </p>
    <pre>
      .ASCII string ;Straight ASCII string
      .ASCIN string ;The last byte of the string has bit 7 set
      .ASCIZ string ;An extra byte of 0 is inserted at the end
                    ;    of the string
    </pre>
  <p>
  Some examples:
  </p>
    <pre>
      .ASCII /123/	;puts (hex) 31 32 33 beginning at the current location
      .ASCIN /123/	;puts (hex) 31 32 B3
      .ASCIZ /123/	;puts (hex) 31 32 33 00
      .ASCII \123\&lt;expr&gt;/456/  ;MAC65: puts 31 32 33 xx 34 35 36
                               ;second set of delimiters doesn't have to match the
                               ;first set of delimiters.
      .ASCII \123\(expr)/456/  ;Others: puts 31 32 33 xx 34 35 36
    </pre>
  <h3 id="dir_asect">.ASECT</h3>
    <pre>
      .ASECT
    </pre>
  <p>  
  This directive sets the current program section to the default absolute
  section and sets the location counter to the value that was last used in
  that section. It is equivalent to:
  </p>
    <pre>
      .PSECT .ABS.
    </pre>
  <p>  
  See the <a href="#dir_psect">.PSECT</a> directive for more details.
    </p>
  <h3 id="dir_blkx">.BLKx and DS.x</h3>
  <pre>
      .BLKB	expression	;allocates space for bytes (8 bits: expression*1)
      .BLKW	expression	;allocates space for words (16 bits: expression*2)
      .BLKL	expression	;allocates space for longs (32 bits: expression*4)
      .BLKQ	expression	;allocates space for quads (64 bits: expression*8)
      .BLKM	expression	;allocates space for expression*minimum addressable unit (MAU)
      .BLK2M expression	;allocates space for expression*2*MAU
      .BLK4M expression	;allocates space for expression*4*MAU
      .BLK8M expression	;allocates space for expression*8*MAU
      DS.B	expression	;(identical to .BLKB)
      DS.W	expression	;(identical to .BLKW)
      DS.L	expression	;(identical to .BLKL)
  </pre>
    <p>
  These directives allocate space in the current program section. They move the
  location counter by the specified number of elements. The expression
  must be absolute but does not have to be positive (a negative value will
  move the location counter backwards). The .BLKW, .BLKL and .BLKQ
  directives will also verify that the current location is aligned
  correctly as indicated by the current section alignment attributes.
  Examples: 
  </p>  
    <pre>
      .BLKB	100		;reserve 100 bytes
      .BLKL	200		;reserve 200 longwords (800 bytes)
    </pre>
  <h3 id="dir_bsect">.BSECT</h3>
  <pre>
    .BSECT
  </pre>
    <p>
  An obsolete directive. See <a href="#dir_psect">.PSECT</a> for details.
    </p>
  <h3 id="dir_byte">.BYTE, .WORD, .LONG, .MAU, .2MAU, .4MAU and DC.x</h3>
    <pre>
      .BYTE [expression[, expression [, ...]]]
      .WORD [expression[, expression [, ...]]]
      .LONG [expression[, expression [, ...]]]
      DC.B	(same as .BYTE)
      DC.W	(same as .WORD)
      DC.L	(same as .LONG)
      .MAU  (same as .BYTE if MAU=8)
      .2MAU (same as .WORD if MAU=8)
      .4MAU (same as .LONG if MAU=8)
    </pre>
    <p>
  All of the above directives have the same syntax. There can be 0 or more
  expressions separated by any construct that is not a valid expression
  term such as a comma or two terms not joined with an expression
  operator. Each expression is inserted in the object code at the next
  higher location. The location counter is verified to have the correct
  alignment according to those specified in the current program section.
  The .BYTE directive places 1 or more bytes in the object file. The .WORD
  directive places one or more 16 bit words in the object file. The .LONG
  directive places one or more 32 bit longwords in the object file.
  Some examples: 
  </p>
    <pre>
      .BYTE                   ;no expression means insert a 0
      .BYTE 1,2,3             ;puts a (hex) 01 02 03 in the output file
      .WORD one two three     ;puts 3 words (6 bytes) in the object file
      .LONG fred + sam foobar ;This puts 2 longs into the output file 
                              ;because fred + sam is a legal expression
                              ;with or without the whitespace. As a result
                              ;the first longword output would be the 
                              ;expression fred+sam and the second longword
                              ;would be the expression foobar.
      .BYTE fred '+ sam foobar ;puts 4 expressions into the output file.
                              ;the '+ is not a valid operator to join two
                              ;terms, so it is assumed to be a term of its
                              ;own. As a result, four expressions are output:
                              ;fred, '+ (hex 2B), sam and foobar.
    </pre>
  <h3 id="dir_csect">.CSECT</h3>
  <p>
    An obsolete directive. See <a href="#dir_psect">.PSECT</a> for details.
    </p>
  <h3 id="dir_define">.DEFINE</h3>
  <p>
  The .DEFINE directive allows for the assignment of an arbirtary string
  to a single assembler symbol. Everywhere in the source between the
  .DEFINE and an .UNDEFINE where the symbol appears, the string will be 
  substituted. It works similar to a #define in the C language. The
  general form is:
  </p>
    <pre>
      .DEFINE symbol an_arbitrary_string [;comments]
    </pre>
  <p>
  where symbol is the name of the symbol which is to be substituted and
  "an_arbitrary_string" is any string of printable characters up to but 
  not including the semicolon delimiting any comments. White space 
  between the symbol name and the string as well as white space between 
  the last character of the string and the comment is not included in the 
  string. Only one level of substitution is performed, that is to say no
  tokens on a .DEFINE or .UNDEFINE directive will be substituted with 
  previously .DEFINE'd symbols. Once a symbol is substituted, the text 
  that has been substituted is not checked for further substitutions.
  Token substitution can take place embedded in strings if the token in
  question is surrounded with apostrophes (the same rules as an argument
  in a macro). Inside macro calls .DEFINEd tokens are replaced after all
  macro arguments are inserted. 
  </p>
    <p>
  Having one or more .DEFINE'd symbols will have an adverse effect on the
  assembler's performance. It is better used in small sections of source
  code (such as during macro definitions), since a symbol can be
  .UNDEFINE'd which will restore the assembler's performance. Examples:
  </p>
    <pre>
        .define fred any string of chars up to a semicolon
        .define foo  a+b		;defines foo
    </pre>
  <p>  
  will force all subsequent occurrences of "fred" in the source file to be
  replaced with the text "any string of chars up to a semicolon" and foo
  to be replaced with the string "a+b". 
  </p>
    <p>
  Note that the text appearing in the list file will be that with all
  tokens substituted. If the resulting assembly of the line produces
  errors, then the original source line will be output to stderr
  (SYS$ERROR) along with the error message but without the line with the
  circumflex (^).
    </p>
  <h3 id="dir_defstack">.DEFSTACK</h3>
    <pre>
    .DEFSTACK <i>stack_name</i> [,<i>size</i> [,<i>type</i>]]
    </pre>
<p>
Defines an array that may be used at assembly time as a stack or as
temporary storage. This is most useful in complex macros that need to
be able to save and have access to large amounts of data. Where:
  </p>
  <table style="width: 50%">
    <tr><th>Parameter</th><th>What parameter does</th></tr>
    <tr><td><i>stack_name</i></td><td>Arbitrary name of stack. This parameter is required.</td></tr>
    <tr><td><i>size</i></td><td>Optional parameter. Expression resolving to absolute value indicating number of elements to allocate.</td></tr>
    <tr><td><i>type</i></td><td>Optional parameter. Can be one of BYTE, WORD, LONG or RELATIVE</td></tr>
  </table>
    <p>
    The <i>stack_name</i> is an arbitrary name of the stack which does not have 
		to be unique from a symbol, macro or opcode name. The
		<i>stack_name</i> is used as an argument to subsequent <b>.PUSH</b>,
		<b>.POP</b>, <b>.SETPOINTER</b> or <b>.GETPOINTER</b> directives. If the <i>size</i> parameter is
    blank or resolves to 0, the stack is deleted and memory returned to the O/S.
	  The <i>type</i> is a keyword of BYTE, WORD, LONG or RELATIVE which
		represents 1, 2, 4 and ~32 byte element sizes respectively.
    If the <i>type</i> parameter is blank the default stack type is set to RELATIVE.
</p>
    <p>
Note that the amount of memory used is the product of the stack size and
the element type size. Care should be taken as not to create an array so
large that there is no memory left for the assembler proper. On MS-DOS
systems, no single array can be larger than 65,536 bytes (32,768 words;
16,384 longs; ~2000 relative values). 
<p>
    <p>
There is a stack pointer associated with each array. The pointer will be
pre-decremented when an item is .PUSH'ed and post-incremented when an item
is .POP'ped. The pointer always moves by one regardless of the size of 
the element. The <b>.GETPOINTER</b> and <b>.PUTPOINTER</b> directives will respectively get or set
the stack pointer on a named stack. Examples:
</p>
    <pre>
    FRED = 100
    .DEFSTACK  temp,FRED+2		;make a temp array of longs
    .DEFSTACK  words,16,WORD	;array of words
    .DEFSTACK  temp			;purge temp array
    </pre>
  <h3 id="dir_enabl">.DSABL and .ENABL</h3>
  <pre>
  .DSABL arg[,...]
  .ENABL arg[,...]
  </pre>
    <p>
  Many of the states and operational characteristics that MACxx provides can be
  enabled or disabled by way of one of these directives.
  The directive .ENABL enables the function(s) and .DSABL disables the function(s).
  The supplied arguments may be one or more the following keywords:
  </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Function</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;ABS</td><td>Obsolete. Has no effect.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;LC</td><td>Obsolete. Has no effect.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;LSB</td><td>Control local symbol block. <a href="#gen_localSymbols">DETAILS</a></td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;USD</td><td>Causes all divides in both local and global expressions
      to be computed using unsigned arithmetic (UnSigned Divide).</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;GBL</td><td>Causes all undefined symbols to automatically be declared
      global. Use with care. </td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;WORD</td><td>Undefined opcodes are assumed to be arguments to a .WORD directive.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;.WORD</td><td>Same as WORD above.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;BYTE</td><td>Undefined opcodes are assumed to be arguments to a .BYTE directive.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;.BYTE</td><td>Same as BYTE above.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;M68</td><td>Causes words and longs to be output big endian.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;TRUNCATE</td><td>Enables/Disables byte/word truncation error <b>checking</b> and <b>reporting</b>.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;LOWER_CASE</td><td>Makes all symbols and labels case sensitive.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;DOLLAR_HEX</td><td>allows hexadecimal constants to be expressed Motorola style ($?=&gt;0x?)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;CR</td><td>Enables carriage returns ('\r') in the source stream otherwise they terminate the line. <font color="red">WARNING:</font> Enabling this function will probably break the .IF BLANK and IDENTICAL conditionals.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;SQUEAK</td><td>Enables internal assembler debug messages<font color="red">WARNING:</font>Enabling this function will produce lots of meaningless output.</td></tr>
    </table>
    <p>
  The following keyword is specific just to MAC65 and 6502.
    </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Function</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;MOS</td><td>MOS TECHNOLOGY 6502 opcode and address mode syntax. <a href="#M65_Addressing">DETAILS</a></td></tr>
  </table>
    <p>
  The following keyword is specific to MAC65, MAC68 and MAC69 for the 6502, 6800 and 6809 processors respectively.
    </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Function</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;AMA</td><td>Use the smallest operand address possible (8 bit vs. 16 bit where known at assembly time).</td></tr>
  </table>
    <p>
    The defaults for all options is DISABLed except for <b><u>TRUNCATE</u></b> which is ENABLed and <b><u>M68</u></b> which is ENABLed on MAC68, MAC69 and MAC68k.
    </p>
  </p>
  <p>
  Some examples:
  </p>
    <pre>
      .ENABL MOS,AMA,USD
      .DSABL WORD,GBL
      .ENABL LSB
    </pre>
  <h3 id="dir_end">.END</h3>
  <p>
  Declares the logical end of assembly and an optional transfer address.
  </p>
    <pre>
      .END [transfer_address]
    </pre>
  <p>  
  The transfer address, if present, must be an expression that resolves to
  a single term that must be defined but can be relocatable. If no transfer address is defined,
  no transfer address will be delivered to LLF. Except for the
  transfer address argument, the directive is ignored by MACxx and
  assembly continues until end of file. The directive is not required. 
    </p>
  <h3 id="dir_endc">.ENDC</h3>
    <pre>
      .ENDC
    </pre>
  <p>
  Declares the end of a conditional block. There must be exactly one 
  matching .IF directive preceding this directive. An error will be
  displayed if a .ENDC directive is encountered outside a conditional 
  block or if a conditional block is opened and not closed with a .ENDC 
  before an end of file is detected. No arguments are required or allowed 
  on this directive.
    </p>
  <h3 id="dir_endm">.ENDM and .ENDR</h3>
    <pre>
      .ENDM [macro_name]
      .ENDR
    </pre>
    <p>
  Declare the end of a macro block. The two directives are identical but
  the .ENDM is typically used to close a .MACRO block and the .ENDR is
  used to close a repeat block (one of .REPT, .IRP or .IRPC). Either
  directive accepts a single argument which, if present, is compared
  against the name of the macro for which it belongs. If the names don't
  match, an error message will be displayed. Repeat blocks are not named
  so no argument should be used on a .ENDR that closes a repeat block.
    </p>
  <h3 id="dir_error">.ERROR</h3>
  <pre>
      .ERROR [[expression] [;comments]]
  </pre>
  <p>  
  This directive generates an error and computes and displays the value 
  of the optional expression. It is useful if included in macros or 
  conditionals to force an error if desired conditions are not met.
  Being that it generates an error, the whole statement will be displayed
  in the list file and on standard error, so the comments can best be
  used to describe the reason for the error.
    </p>
  <h3 id="dir_escape">.ESCAPE</h3>
  <pre>
    .ESCAPE keyword=expression[,...]
  </pre>
    <p>
  This directive allows the changing of various escape characters. 
  Currently the only characters that can be changed are the macro escape 
  characters. Keyword is one of the strings itemized below and expression is an 
  absolute expression that resolves to a printing but non-alphanumeric 
  character. 
  </p>
  <table style="width: 30%">
    <tr><th>Keyword</th><th>Default</th><th>Function</th></tr>
    <tr><td>MACRO_OPEN</td><td>'&lt;</td><td>Start of macro argument</td></tr>
    <tr><td>MACRO_CLOSE</td><td>'&gt;</td><td>End of macro argument</td></tr>
    <tr><td>MACRO_ESCAPE</td><td>'^</td><td>Alternate macro argument delimiter</td></tr>
    <tr><td>MACRO_GENSYM</td><td>'?</td><td>Indicates macro argument is autogenerated</td></tr>
    <tr><td>MACRO_GENVAL</td><td>'\</td><td>Convert macro argument to ASCII</td></tr>
  </table>
  <h3 id="dir_even">.EVEN and .ODD</h3>
  <pre>
    .EVEN
    .ODD
  </pre>
    <p>
  These directives force the current location counter to the next higher
  even or odd value respectively. Note that the PSECT attributes of the current program
  section must enforce a section alignment of at least 1 (word alignment)
  in order for this directive to really do what is desired. If the psect
  attributes do not enforce at least a word alignment, then the section
  may not be located on an even or odd address by LLF. If that happens, the
    effect of the .EVEN will become .ODD and visa-versa. A warning will be displayed by
  the assembler if this condition is present. This directive neither 
  requires nor accepts any arguments. See <a href="#dir_align">.ALIGN</a> and
    <a href="#dir_psect">.PSECT</a> for additional alignment options.
    </p>
  <h3 id="dir_globl">.GLOBL, .GLOBB, .GLOBS, .GLOBR, xref, xref.s, .LOCAL and .STATIC</h3>
  <pre>  
      .GLOBx symbol_1[,symbol_2,...]
  </pre>
  <p>  
  These directives declare one or more symbols or labels as being either global
  or local in scope. That is the listed symbols or labels are made known to
  LLF. The symbols or labels may or may not be defined when this directive
    is issued. The .LOCAL and .STATIC not necessary unless the .ENABL GBL option
    is in effect. They force the supplied symbols to remain local even if not
    defined. If they are not defined anywhere in the source code, then they will be assumed to be
  defined in another module or explicitly by LLF. The .GLOBL directive is
  the general case for declaring ordinary symbols or labels as global in
  scope. The .GLOBR directive declares the symbols as being both global in
  scope and of type register (same as .GLOBL in MAC65). The .GLOBB
  directive declares the symbols or labels as being resident in base page
  (zero page), and at present is only significant to MAC65. The .GLOBS
  directive identifies labels and symbols as accessible via "short" (i.e.
  16 bit offset) address modes in MAC68K (the directive is identical to a
  .GLOBB). Any number of symbols may be listed separated with white space
  or commas. 
    </p>
  <h3 id="dir_if">.IF, .IFF and .IFTF</h3>
    <pre>
      .IF keyword,expression  [;comments]
      .IFF
      .IFT
      .IFTF
    </pre>
  <p>
  This is the general case conditional directive. It opens a conditional
  block which encompasses all the source code between the .IF and a
  matching .ENDC directive. The sense of the conditional can be changed
  with the .IFF (If False), .IFT (If True) and .IFTF (If True or False).
  While the condition is true, the source code is assembled. While the
  condition is false, the source code is examined only for conditional
  directives and otherwise is ignored. The condition is closed when the
  matching .ENDC is encountered. Conditional blocks can be nested to 32
  levels within a single macro level. That is, each level of macro call
  (including the 0th level) has 32 levels of conditional nesting. 
  The keyword determines what type of condition is to be tested.
    For the following keywords, the expression must resolve to an absolute value:
    </p>
  
  <table style="width: 25%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>EQ</td><td>Zero</td></tr>
    <tr><td>NE</td><td>Not zero</td></tr>
    <tr><td>G</td><td>Greater than zero</td></tr>
    <tr><td>GT</td><td>Greater than zero</td></tr>
    <tr><td>GE</td><td>Greater or equal to zero</td></tr>
    <tr><td>L</td><td>Less than zero</td></tr>
    <tr><td>LT</td><td>Less than zero</td></tr>
    <tr><td>LE</td><td>Less than or equal to zero</td></tr>
    <tr><td>NZ</td><td>Not zero (same as NE)</td></tr>
    <tr><td>Z</td><td>Equal to zero (same as EQ)</td></tr>
    <tr><td>T</td><td>Not zero (same as NE)</td></tr>
    <tr><td>F</td><td>Zero (same as EQ)</td></tr>
    <tr><td>EQUAL</td><td>Zero (same as EQ)</td></tr>
    <tr><td>NOT_EQUAL</td><td>Not zero (same as NE)</td></tr>
    <tr><td>GREATER_THAN</td><td>Greater than zero (same as GT)</td></tr>
    <tr><td>GREATER_OR_EQUAL</td><td>Greater or equal to zero (same as GE)</td></tr>
    <tr><td>LESS_THAN</td><td>Less than zero (same as LT)</td></tr>
    <tr><td>LESS_OR_EQUAL</td><td>Less than or equal to zero (same as LE)</td></tr>
    <tr><td>NOT_ZERO</td><td>Not zero (same as NE)</td></tr>
    <tr><td>ZERO</td><td>Zero (same as EQ)</td></tr>
    <tr><td>TRUE</td><td>Not zero (same as T)</td></tr>
    <tr><td>FALSE</td><td>Zero (same as F)</td></tr>
  </table>  
    <p>
  There are three special case .IF's that use something other than an 
  expression to determine the test. These cases are:
  </p>
    <pre>
      .IF keyword,symbol_expression
    </pre>
  <table style="width: 25%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>DF</td><td>Symbol is defined</td></tr>
    <tr><td>NDF</td><td>Symbol is not defined</td></tr>
    <tr><td>DEFINED</td><td>Symbol is defined</td></tr>
    <tr><td>NOT_DEFINED</td><td>Symbol is not defined</td></tr>
    <tr><td>EXISTS</td><td>All terms in expression exist</td></tr>
    <tr><td>EXIST</td><td>All terms in expression exist</td></tr>
    <tr><td>NOT_EXISTS</td><td>Any term in expression does not exist</td></tr>
    <tr><td>NOT_EXIST</td><td>Any term in expression does not exist</td></tr>
  </table>  
    <p>
  In the DF, NDF, EXISTS, NOT_EXIST cases, the symbol_expression may be more than one symbol separated with 
  either a ampersand (&) for AND or a vertical bar (|) for OR (an
  exclamation point (!) in MAC65). For example:
    </p>
    <pre>
       .IF DF, LABEL1 & LABEL2
    </pre>
    <p>
  indicates the condition is true only if both label1 and label2 are
  defined. 
    </p>
    <p>
    The other special condtion test is for blank or not-blank. It follows the syntax:
    </p>
  <pre>
      .IF keyword,string
  </pre>
  
  <table style="width: 25%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>B</td><td>String is blank</td></tr>
    <tr><td>NB</td><td>String is not blank</td></tr>
    <tr><td>BLANK</td><td>String is blank</td></tr>
    <tr><td>NOT_BLANK</td><td>String is not blank</td></tr>
  </table>  
    <p>
    Note that if the string is enclosed in macro argument delimiters
    (normally &lt;&gt;'s) then only the contents between the delimiters is
    tested for blank or not blank. Otherwise, if ANY text appears on
    the line after the comma separating the condition, the "string"
    is considered not blank. This directive only is allowed (or
    useful) inside a macro. 
  </p>
    <p>
    The last special case conditional allows for comparing strings.
    It has the syntax:
    <pre>
      .IF keyword,string1,string2
    </pre>
  
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>DIF</td><td>String1 is different than string2</td></tr>
    <tr><td>IDN</td><td>String1 is identical to string2</td></tr>
    <tr><td>DIFFERENT</td><td>String1 is different than string2</td></tr>
    <tr><td>IDENTICAL</td><td>String1 is identical to string2</td></tr>
    <tr><td>SAME</td><td>String1 is identical to string2</td></tr>
  </table>  
  <p>  
    Note that string1 and string2 are compared with a simple string
    compare. They must match exactly to be considered identical. If
    either or both of the strings are enclosed in macro argument
    delimiters (normally &lt;&gt;'s), then only the contents between the
    delimters is compared. Some examples:
  </p>
    <pre>
      .IF eq,FRED            ;true if FRED is 0
      .IF GT,LAB1-LAB2*100   ;true if result is greater than 0
      .if ne,LABL-9          ;true if LABL is not 9
      .if NE,FLAGS&100       ;true if bit 8 set in FLAGS
      .if idn,&lt;arg1&gt;,&lt;arg2&gt;  ;true if macro arg1 is same as arg2
      .if ndf,label          ;true if LABEL is not defined
      .if defined, label1 & label2 ;true if both labels are defined
      .if b,&lt;param3&gt;         ;true if macro param 3 blank
      .IF EQ,FLAG            ;open a conditional
      ...some source         ;stuff to do if flag is 0
      .IFF                   ;kinda like an ELSE
      ...some source         ;stuff to do if flag is not 0
      .IFTF
      ...more source         ;stuff to do regardless of flag value
      .IFT
      ...still more          ;stuff to do if flag is 0
      .ENDC                  ;done with conditional
    </pre>
  <h3 id="dir_iif">.IIF</h3>
        <pre>
        .IIF keyword,args,statement [;comments]
        </pre>
  <p>
  This is a special one line conditional (Immediate IF). It has the same
  syntax and rules as the .IF directive above except the single statement to be 
  executed follows the conditional argument(s) separated with a comma.
  See <a href="#dir_if">.IF</a> for details about the conditionals. Examples:
  </p>
  <pre>  
      .IIF NDF,LABEL,LABEL = 100	;define if not already defined
      .IIF EQ,LAB1-10,.error LAB1 	;LAB1 is too big
      .IIF b,&lt;arg5&gt;,.error		;No ARG5 argument supplied
  </pre>

  <h3 id="dir_include">.INCLUDE</h3>
        <pre>
      .INCLUDE filename	[;comments]
        </pre>
  <p>
  This directive allows for additional source files to be included for 
  assembly. Note that the semicolon delimits comments so, on VMS systems anyway, 
  one cannot specify version numbers on filenames. The filename string
  is has the default filetype (.MAC or .mac) appended to it if required and is
  passed otherwise unmodified to the operating system. The filename
  syntax is that of the underlying operating system.
  </p>
  <h3 id="dir_irp">.IRP</h3>
  <pre>
    .IRP dummy_arg,&lt;arg1[[,]arg2[...[,]argn]]&gt;
    macro_body
    .ENDR
  </pre>
    <p>
  The .IRP and .IRPC directives define an indefinite repeat block which is
  simply a macro definition with a single dummy argument (macro <a href="#gen_macros">DETAILS</a>)
  followed with an immediate call. The macro is expanded once for each argument supplied on the
  directive. The macro_body is one or more lines of assembly code to be repeated
  for each argument in the argument list and <b>dummy_arg</b> in the example is the text
  string to be replaced at its each occurance in the macro body. On each iteration of the indefinite
  repeat block, the <b>dummy_arg</b> assumes the value of each successive
  argument in the argument list. Indefinite repeat blocks may be used
  anywhere a macro may be used and is, in fact, a macro definition itself
  with an automatic call at the end of the definition. Arguments in the
  argument list are delimited with white space or commas. Arguments
  containing white space, semicolons and/or commas may be enclosed in
  macro argument delimiters (normally &lt;&gt;'s). There may be no more
  than 125 arguments. Examples: 
  </p>
    <pre>
      .IRP xx,&lt;one,two,three&gt;
      .word xx,xx+1
      fred xx
      .endr
    </pre>
  <p>
  would expand to the following:
  </p>
  <pre>
    .word one,one+1
    fred one
    .word two,two+1
    fred two
    .word three,three+1
    fred three
  </pre>
  <p>
  Another example might be in a general CALL macro where an arbitrary
  number of arguments needs to pushed on a stack, a function called, then
  the arguments purged from the stack. It could be coded something like
  this:
  </p>
  <pre>
    .MACRO CALL FUNCTION ARG_LIST
    ...1 = 0                   ;argument counter
    .IRP ARG,&lt;ARG_LIST&gt;  ;for each argument in the list
    PUSH ARG                   ;push it on the stack
    ...1 = ...1 + 1            ;count it
    .ENDR
    JSR FUNCTION               ;goto function
    ADD #...1,SP               ;adjust the stack
    .ENDM CALL
  </pre>
  <p>  
  Then the macro CALL would be envoked like:
  </p>
    <pre>
      CALL DO_IT &lt;FRED,FOOBAR,FUBAR&gt;
    </pre>
  <p>
  A .MEXIT or .REXIT directive causes the macro expansion to skip to the
  end of the repeat block. If additional arguments remain in the list, the
  repeat block is called with the next argument in line. See also <b>.IRPC</b>,
  .MEXIT, .REXIT and .MACRO <a href="#gen_macros">HERE</a>.
    </p>
  <h3 id="dir_irpc">.IRPC</h3>
  <p>
  Identical to the <a href="#dir_irp">.IRP</a> except the dummy argument is successively 
  replaced with each single character in the argument list. The argument list in 
  this instance is treated as a single string delimited with the &lt;&gt;'s.
  Example:
  </p>
    <pre>
      .IRPC xx,&lt;any_string_of_chars&gt;
      .byte ''xx
      .endr
    </pre>
  <p>  
  would expand to a .BYTE directive for each character in the string
  "any_string_of_chars". For example:
  </p>
  <pre>
    .IRPC xx,&lt;123&gt;
    .byte ''xx
    .endr
  </pre>
  <p>Would expand to:</p>
  <pre>
  .byte '1
  .byte '2
  .byte '3
  </pre>
  <p>
     See also .IRP, .MEXIT, .REXIT and .MACRO <a href="#gen_macros">HERE</a>.
  </p>
  <h3 id="dir_length">.LENGTH</h3>
    <pre>
    .LENGTH keyword=n[,...]
    </pre>
  <p>
  The .LENGTH directive sets the significant length of symbols and/or
  opcode/pseudo-op/macro names. It is recommended that the length be
  selected on the command line rather than with this pseudo-op since
  changing the significant number of characters during the assembly
  may make previously defined symbols and/or macros inaccessible.
  </p>
  The <b>keyword</b> may be one of SYMBOL, OPCODE or MAU and <b>n</b>
  in the example above is a value between 6 and 32 inclusive.
  SYMBOL represents the lengths of user defined symbols and labels
  and OPCODE represents the lengths of opcodes, pseudo-ops and macro names.
    The MAU argument sets the Minimum Addressable Unit in bits and can be
    between 8 and 32. For example:
  </p>
  <pre>
  .LENGTH SYMBOL=32,OPCODE=32   ;Symbols and opcodes/macros have 32 character significance
  .LENGTH MAU=16                ;Set the minimum addressable unit to 16 bits
  </pre>
  <h3 id="dir_list">.LIST and .NLIST</h3>
    <pre>
      .LIST [arg[,...]]
      .NLIST [arg[,...]]
    </pre>
  <p>  
  Listing control options can be specified via the directives .LIST
  (enable) and .NLIST (disable). The optional argument list
  represents 0, one or more arguments separated by commas. When
  used without arguments, the listing directives alter the listing level
  count. The listing level count causes the listing to be suppressed when
  less than 0, all items to be listed when greater than 0 and individual
  listing item controls operate when the level count equals 0. The listing
  level count is initialized to 0 at the start of the assembly,
  incremented for each .LIST (without an argument) and decremented for
  each .NLIST (without an argument). The allowable arguments, their
  function and the default values are as follows: 
  </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Default</th><th>Function</th></tr>
    <tr><td>BIN</td><td>list</td><td>list/nlist generated binary code</td></tr>
    <tr><td>BEX</td><td>list</td><td>list/nlist generated binary code that overflows a single line</td></tr>
    <tr><td>CND</td><td>no list</td><td>list conditional directives and blocks or nlist both conditional directives and unsatisfied conditional blocks.</td></tr>
    <tr><td>COD</td><td>no list</td><td>list/nlist the generated binary code "as stored" in the object file rather than "as used". See <a href="#gen_list_examples">EXAMPLES</a>.</td></tr>
    <tr><td>COM</td><td>list</td><td>list/nlist comments</td></tr>
    <tr><td>LD</td><td>no list</td><td>list/nlist listing directives that have no arguments.</td></tr>
    <tr><td>LOC</td><td>list</td><td>list/nlist the current location counter (pc).</td></tr>
    <tr><td>MC</td><td>list</td><td>list/nlist macro calls.</td></tr>
    <tr><td>MD</td><td>list</td><td>list/nlist macro definitions</td></tr>
    <tr><td>ME</td><td>no list</td><td>list/nlist macro expansion source</td></tr>
    <tr><td>MEB</td><td>no list</td><td>list/nlist macro call and only the binary it generates.</td></tr>
    <tr><td>MES</td><td>no list</td><td>list/nlist macro call and only expansion lines that generate binary or call another macro.</td></tr>
    <tr><td>SEQ</td><td>list</td><td>list/nlist the statement sequence number</td></tr>
    <tr><td>SRC</td><td>list</td><td>list/nlist the source code.</td></tr>
    <tr><td>SYM</td><td>list</td><td>list/nlist the symbol table at the end of the assembly listing.</td></tr>
    <tr><td>TOC</td><td>list</td><td>list/nlist option ignored in macxx.</td></tr>
    <tr><td>TTM</td><td>list</td><td>list/nlist option ignored in macxx.</td></tr>
   </table>
    <p>
  There is a special case in the use of MEB and MES which will cause the
  binary generated by a macro to appear on the same line as the macro
  call. This option is selected with the combination of .LIST MEB and
  .NLIST MES.
  </p>
  <p id="gen_list_examples">
  Examples:
  <p>
    <pre>
      .LIST          ;increments the list level. If the count becomes &gt; 0 then all items are listed.
      .LIST MEB      ;list macro call and any binary produced by macro.
      .LIST MES      ;list macro call and only lines within macro that produce binary.
      .LIST COD		   ;causes the binary to be displayed "as
                     ;   stored" rather than "as used". This
                     ;   option is significant only on little
                     ;   endian machines (6502, ASAP). i.e.:
      .WORD 0x1234   ;binary displayed as 1234 if .NLIST COD
                     ;  "       "      "  3412 if .LIST COD
                     ;  on a little endian machine
      .LIST ME,CND,SRC,SYM	;multiple arguments can be specified
      .NLIST         ;decrements the list level. If the count becomes &lt; 0 then all items are suppressed from listing.
    </pre>
  </p></p>
  <p id="dir_list_src">  
    The .LIST SRC has special options to allow control where on listing line the source text is placed.
    These options are provided by including them in surrounding parenthesis immediately following the SRC directive.
  </p>
  <p> Examples:
    <pre>
    .LIST <i>[...,]</i>SRC<i>[=]</i>(<i><b>aa</b>[,<b>bb</b>[,<b>cc</b>]]</i>)<i>[,...]</i>
    
    Where <i>[]</i> indicates optional arguments:
    <i><b>aa</b></i> = column on the listing line where to place the first character of the source (default is 40).
    <i><b>bb</b></i> = If present means apply these changes on the next source line.
    <i><b>cc</b></i> = If present means to flush the listing output.
    </pre>
  </p>
  <p>
    See the <a href="#dir_print_examples">these examples</a> for some what can be done with this option.
  </p>
  <h3 id="dir_long">.LONG</h3>
    <pre>
      .LONG [expression[,...]]
      DC.L	(same as .LONG)
    </pre>
  <p>
  See <a href="#dir_byte">.BYTE</a> for details.
    </p>
  <h3 id="dir_macro">.MACRO</h3>
    <pre>
      .MACRO macro_name [[,]dummy_argument_list[,...]]	[;comments]
    </pre>
  <p>
  This is the first statement in a macro definition. Putting a label on a
  .MACRO directive may prove misleading, however, the value assigned to
  the label will be whatever the current location counter is set to (as
  with any other label) without regard to anything in the macro
  definition. Macro definitions do not move the location counter nor do
  they affect the local symbol blocks.
    </p>
    <p>
  The <u>macro_name</u> is the name of the macro which is any legal symbol and is
  what is used to subsequently call the macro. The macro name is inserted
  in the opcode symbol table which is separate and distinct from the user
  symbol table and means the macro name can be the same as a symbol or
  label without conflict. 
  </p>
    <p>
  The <u>dummy_argument_list</u> is zero, one or more legal string symbols which may
  appear anywhere in body of the macro definition. These symbols are only
  significant during the macro definition (i.e. they are simply place
  markers) and as such will not conflict with like named symbols anywhere
  else in the assembly text. The <u>macro_name</u> and <u>dummy_arguments</u> must be
  separated from one another by commas or white space. No syntax checking
  is done on the body of the macro until the macro is later called. Tokens
  appearing in the macro body are separated and inspected to see if they
  match one of the dummy arguments and, if so, replaced with a marker
  indicating an argument number. When the macro is called, the argument(s)
  on the macro call are inserted into the macro body at the appropriate
  places according to the identifying markers. 
  <p>
  See <a href="#gen_macros">MACRO section</a> for details and examples about the use of macros.
    </p>
  <h3 id="dir_mexit">.MEXIT</h3>
    <pre>
      .MEXIT [expression]
      .REXIT
    </pre>
  <p>
  The .MEXIT and .REXIT directives are an implementation of an alternate exit from a
  macro or repeat block. Upon encountering a .MEXIT directive during a
  macro expansion (not during a macro definition), the macro or repeat block after being called is
  immediately terminated as though it were an .ENDM or .ENDR. This is particularly
  useful in complex conditional structures in that it is a functional
  equivalent to a "goto end_of_macro". The <u>expression></u>
  is optional but, if present, must resolve to an absolute
  value and it indicates how many macro levels to exit. The effect of the 
  .MEXIT or .REXIT is different between ordinary macros and repeat blocks. If the 
  expression argument is blank then the behavior is according to the 
  following truth table:
  </p>
  <table style="width: 100%">
    <tr><th>Macro Type</th><th>Action</th></tr>
    <tr><td>Ordinary</td><td>macro is exited</td></tr>
    <tr><td>repeat block</td><td>block is exited and the repeat count is 
        decremented or the next argument selected;
        block will be re-executed if the repeat
        count remains greater than 0 or argument
        list has not been exhausted.</td></tr>
  </table>
    <p>
  If the expression is present and it resolves to a value less than 0 then
  the .MEXIT or .REXIT is ignored. If the expression resolves to a value greater than 0,
  then that value is used as a count of the number of macro levels to exit.
  A repeat block is considered 1 macro level regardless of its count or
  argument list size. Therefore, a ".MEXIT 1" or ".REXIT 1" in a repeat block will exit
  the block and terminate it as though the count reached 0 or the argument
  list had become exhausted. 
  </p>
    <p>
  If the expression resolves to a value of 0 then the exit behaves according
  to the following truth table:
  </p>
  <table style="width: 100%">
    <tr><th>Macro Type</th><th>Action</th></tr>
    <tr><td>Ordinary</td><td>.MEXIT or .REXIT is ignored</td></tr>
    <tr><td>repeat block</td><td>block is exited and the repeat count is 
        reduced or the next argument selected;
        block will be re-executed if the repeat
        count remains greater than 0 or argument
        list has not been exhausted.</td></tr>
  </table>
    <p>
  The current condition levels (as created by .IF/.ENDC directives)
  are saved and reset to 0 when each macro is called. They are restored
  when the macro exits. The condition levels will be restored correctly
  regardless of how many macro levels are exited.
  </p>
    <p>
  Some examples:
  </p>
    <pre>
      .MACRO TST ARG_LIST
      .IF FALSE, expression
      ...
      .ERROR 	;Report some kind of problem
      .MEXIT	;and skip the rest of the macro
      ...
      .ENDC
      ...
      .ENDM
    
      .IRP XX,&lt;ARG_LIST&gt;
      .IF BLANK, &lt;XX&gt;
      .MEXIT	;don't do anything if argument is blank,
        ;but continue with next argument in list
      .ENDC
      ...
      .IF TRUE, expression
      .ERROR	 ;found some kind of problem
      .MEXIT 1 ;so don't continue the repeat block
      .ENDC
      ...
      .ENDR
    
      .MACRO RECURS ARG_LIST
      .IF TRUE, expression
      RECURS NEW_ARG_LIST
      .IFF
      .IF FALSE, expression
      .ERROR	;Maybe something terrible, or the macro did all it
        ;was supposed to do, so...
      .MEXIT 100000	;Bump all the way out to the top level
      .ENDC
      ...
      .ENDC
      .ENDM
    </pre>
  <h3 id="dir_mdelete">.MDELETE</h3>
  <pre>  
      .MDELETE macro_name[,...]
  </pre>
    <p>
  Deletes macros from memory and frees all the memory associated with the
  macro. The <u>macro_name</u> is one or more macro names separated by commas.
    </p>
  <h3 id="dir_narg">.NARG</h3>
    <pre>
      .NARG symbol
    </pre>
  <p>
  Gets the number of arguments passed to a macro. The <u>symbol</u>
  argument is the name of a symbol that is assigned a value equal to 
  the number of arguments in the macro call. If this directive is used 
  outside a macro, the symbol will be assigned a value of 0.
  </p>
  <p>
  The number of arguments in a  .REPT block is always 0. The number of
  arguments in a .IRP or .IRPC can be 0 or 1 but never more than 1. The
  symbol needn't have been used before, but it must be eligible for
  redefinition.
    </p>
  <h3 id="dir_nchr">.NCHR</h3>
  <pre>  
      .NCHR symbol [,] string
  </pre>
    <p>
  Gets the number of characters in a character string and assigns the 
  length to a symbol. The <u>symbol</u> is assigned a value equal to the number of characters in
  string. The string must be enclosed between macro argument delimiters
  (normally &lt;&gt;'s) if the string contains semicolons, leading commas or
  white space. The symbol needn't have been used before, but it must be
  eligible for redefinition. Some examples:
    </p>
    <pre>
      .MACRO ascic string
      .nchr length,&lt;string&gt;
      .byte length
      .ascii \string\
      .endm
    
      ascic &lt;Hello World&gt;
    </pre>
  <h3 id="dir_nlist">.NLIST</h3>
  <p>
  Decrements the listing level or disables certain list options. See 
  <a href="#dir_list">.LIST</a> for details.
  <h3 id="dir_odd">.ODD</h3>
  <pre>
  .ODD
  </pre>
    <p>
  This directive forces the current location counter to the next higher
  odd value. Note that the PSECT attributes of the current program
  section must enforce a section alignment of at least 1 (word alignment)
  in order for this directive to really do what is desired. If the psect
  attributes do not enforce at least a word alignment, then the section
  may not be located on an even address by LLF (which will make the
  effect of the .ODD to become a .EVEN). A warning will be displayed by
  the assembler if this condition is present. This directive neither 
  requires nor accepts any arguments. See <a href="#dir_even">.EVEN</a>
  and <a href="#dir_align">.ALIGN</a> for additional alignment options.
    </p>
  <h3 id="dir_outfile">.OUTFILE</h3>
    <pre>
    .OUTFILE expression
    </pre>
    <p>
    The expression must resolve to an absolute <b>n</b> where 0&lt;<b>n</b>&lt;max_outputs
    and max_outputs is the number of <b>OUT</b> command line options supplied. This
    directive only applies to MACPP. Any number of <b>OUT</b> command line options
    are accepted. They index according to their placement on the command line: 0 is
    the first, 1 is the second, etc. For example:
    </p>
    <pre>
    macpp -out=file0 -out=file1 inFile
    ;And the content of inFile would be:
    This line and all above it would go into file0
    .OUTFILE 1  ;Switch to the other output file
    This line would go into file1
    .OUTFILE 0  ;Switch back to the first output file
    This line would continue in file0.
    </pre>
  <h3 id="dir_page">.PAGE</h3>
  <pre>
  .PAGE
  </pre>
    <p>
  Inserts a form feed in the listing file. The .PAGE directive itself is 
  not printed. A .PAGE in a macro definition is ignored until the macro 
  is called. The directive accepts no arguments.
    </p>

  <h3 id="dir_pop">.POP</h3>
  <pre>
  .POP <i>stack_name</i>,<i>symbol1</i>[,<i>symbol2</i>[,...]]
  </pre>
    <p>
    Pops one or more items from the specified user stack and assigns the value(s) to
    each successive listed symbol names. Note the assignment is identical to that
    of the simple syntax <b><i>symbol_name=expression</i></b> where <b><i>symbol_name</i></b> may or may not
    be an already defined symbol. If the <b><i>symbol_name</i></b> has not already been defined
    the .POP will create a new symbol. It may be important to note just the value of the
    symbol is changed. None of the existing symbol flags are altered. That is, for
    example, if the <b><i>symbol_name</i></b> has been declared global, it will remain global just
    as it would during any subsequent <b><i>symbol_name=expression</i></b> statement. Also note, if
    the stack is of type RELATIVE, the assigned value may be either an absolute, a simple
    relative (section+offset) or even a complex expression including internal and external
    relocation information. Stack types of BYTE, WORD or LONG only contain absolute integers.
    </p>
    <p>It is not legal to pop to a <b><i>symbol_name</i></b> that has previously been defined as a label or, in the case of
    running in two pass mode, a forward reference. The assembler will emit an error in
    the illegal cases.
    </p>
    <p>There is the special case of POP'ing a program counter directly. This is indicted
    by having the <b><i>symbol_name</i></b> be the single period, <b>.</b>. If the stack type is
    RELATIVE the current section might be changed too although the assembler will emit a warning
    if the section is changed as a result. In all other cases the popped value simply
    sets the PC's section offset. Use care with this function if changing sections.
    </p>
    
  <h3 id="dir_print">.PRINT</h3>
    <p>This directive has two forms (the <b><i>[]</i></b>'s indicate optional arguments):</p>
  <pre>  
    .PRINT [expr]  [; message]
  </pre>
  <p>Will display the result of the optional expression and the text of what would otherwise be
    a comment as an assembly error. This is expected to be used in a macro to allow the programmer
    to indicate an error condition.
  </p>
  <p>The other form:</p>
  <pre>
    .PRINT expr(<i><b>aa</b>[,<b>bb</b>[,<b>cc</b>[,<b>dd</b>[,<b>ee</b>[,<b>ff</b>]]]]]</i><b>)</b>  [; comment]
  </pre>
  <p>
    Prints the results of the expression beginning at the column specified by the <b><i>aa</i></b> parameter and according to
    the other optional parameters. In this form the comment remains as a comment.<br>
    <b>NOTE:</b>What distinguishes this form from the one listed above is the presence of the <b>()</b>'s delimited content immediately following the
    expression.
  </p>
  <p>
  The arguments in this form are defined as follows:
  </p>
  </p>
    <pre>
    <b><i>aa</i></b> = expression indicating column position on the listing line to start the number output.
    <b><i>bb</i></b> = expression indicating length of number text (0=however long the number converts to text; max of 16)
    <b><i>cc</i></b> = expression resolving to radix to use to convert according to:
         0 = current selected radix
         1 = default radix for macxx
         2 = binary radix
         8 = octal radix
        10 = decimal radix
        16 = hexidecimal radix
    <b><i>dd</i></b> = if not zero, include leading zeros.
    <b><i>ee</i></b> = if not zero, include a +/- sign as appropriate.
    <b><i>ff</i></b> = if the single character '/', flush the line to listing.
    </pre>
  <p>
    Technically, the single character '/' can appear in any of the positions to indicate to flush the line to listing. And if present as such, does not change
    the order of the rest of the arguments.
  </p>
  <p>
    There is one additional special parameter that may be used in any of the argument positions. It does not replace the argument, but as with the '/' character above,
    does not change the order or presence of any of the arguments as defined. It consists of two items: an expression and immediate text delimited with single quotes.
    The expression resolves to the column where to place the text and the quoted text, sans quotes, is placed on the listing line starting at the supplied column.
    For a better description, see the following examples.
  </p>
  <p>
  Some examples:
  </p>
    <pre>
    number_data = 12
    .PRINT number_data                     ; This is the assembler error message that will be displayed along with the hexidecimal of 12
    len = 3
    txt = 43
    num = 40
    rad = 10
    lz = 1
    .PRINT number_data(txt'->',num,len,rad,lz) ; Displays a number 12 in decimal in 3 positions with leading zeros starting at column 43
                                               ;   It also deposits the text <b>-></b> at columns 40 and 41
    number_data = 23
    txt = 46
    .PRINT number_data(num,len,rad,lz,txt'<-') ; Displays a number 23 in decimal in 3 positions with leading zeros starting at column 43
                                               ;   It also deposits the text <b><-</b> at columns 46 and 47
    number_data = 34
    num = 44
    .PRINT number_data(num,/,len)              ; Displays a number 34 in decimal in 2 positions without leading zeros starting at column 44
                                               ;   It also flushes the line to the listing file.
    </pre>
  <p id="dir_print_examples">
     Here are some examples of the listing output one might see if using macros properly designed
     to use the features of the .PRINT directive coupled with the  <a href="#dir_list_src">.LIST SRC</a> with its () options:
  </p>
  <pre>
    43   006A    24    FE           0->         IFLO                    ;NO, GO ON
    44                              1->            BEGIN                   ;PROCESS LIST
    45   006C  E6C0                                   LDB (U)+
    46   006E    C1    D6                             CMPB #MESSZ             ;IS IT A VALID MESSAGE NUMBER?
    47   0070    24    FE           2->               IFLO                    ;YES, DO IT
    48   0072    F7  0000G                               STB MESNUM              ;SAVE IT FOR LATER--->MESOUT
    49   0075    BD  0F1D'                               JSR MOUT2               ;OUTPUT CHARACTERS
    50   0071    06                 2<-               ENDIF
    51   0078  11B3  0000G                            CMPU MESLST             ;DONE? (U UPDATED AT BEGINNING OF LOOP)
    52   007C    25    EE           1<-            HSEND
    53   006B    12                 0<-         ENDIF
    54  
  </pre>
  <p>
  As a complete example of the definitions of the approrpate macros for a 6052 implentation of these features, look at the hll65f.mac included
  with the macxx source kit for details.
  </p>
      
  <h3 id="dir_psect">.PSECT</h3>
  <pre>  
    .PSECT name[,argument...]
  </pre>
    <p>
  This directive defines the name and attributes of a program section
  and sets the current location to that section. The <u>name</u> argument
  is the name of the section and the arguments are a list of 0 or 
  more attributes to be assigned to the section. The attributes, their 
  meaning and default values are as follows:
  </p>
  <table style="width: 100%">
    <tr><th>Argument</th><th>Meaning</th></tr>
    <tr><td>ABS</td><td>Section is absolute; I.e. positioned is fixed at address 0</td></tr>
    <tr><td>REL</td><td>Section is relative; I.e. final position is set by LLF</td></tr>
    <tr><td>CON</td><td>Section is to be concatenated by LLF with like named sections</td></tr>
    <tr><td>OVR</td><td>Section is to be overlayed by LLF with like named sections</td></tr>
    <tr><td>BASE</td><td>Section is relative but in zero page (MAC65 only; opcodes use zero page addressing for operands in here)</td></tr>
    <tr><td>OUT</td><td>Section data is output to object file</td></tr>
    <tr><td>NOOUT</td><td>Section data is NOT output in object file</td></tr>
    <tr><td>RO</td><td>Section is read-only</td></tr>
    <tr><td>RW</td><td>Section is read-write</td></tr>
    <tr><td>DATA=n</td><td><b>n</b> specifies the data alignment within section</td></tr>
    <tr><td>SEGMENT=n</td><td><b>n</b> specifies the alignment LLF should use to place the section</td></tr>
    <tr><td>MAX_LENGTH=n</td><td><b>n</b> specifies the maximum size the section may be</td></tr>
  </table>  
    <p>
  Absolute and relocatable are terms that describe how the section is 
  placed in the target memory by LLF. If the section is absolute, then 
  the text and labels are fixed at a specific memory location by the 
  assembler and as such will be placed in the target memory at that same 
  location. LLF will not "move" or "relocate" the section somewhere else.
  If the section is relocatable, however, then the text and labels are 
  not fixed at a specific memory location at assembly time and enough 
  information is passed through to LLF so it can re-position the section 
  to an appropriate place in the target memory and adjust the values of
  the labels accordingly. A section can be either absolute or relocatable 
  but not both. The default for all assemblers is REL.
  </p>
    <p>
  Concatenate and overlay are terms that describe how sections having the
  same name are handled by LLF. If a section is declared as CON, LLF will
  collect all sections having that section's name together appending one
  to the other forming one large section the size of which will be the sum
  of the sizes of each of the members. If a section is declared as OVR,
  LLF will collect all sections having that section's name and overlay one
  on top of another creating one section whose size is the size of the
  largest of them. A section can be either CON or OVR but not both.
  The default for all assemblers is CON. 
  </p>
    <p>
  A section can be declared as being a BASE page in MAC65. This tells the
  assembler that even though the section might be relocatable, all
  automatic address mode references to labels defined in this section be
  done with zero page addressing mode. The default is not BASE.
  </p>
    <p>
  A section may declared as a "memory place holder". That is text may be 
  put in the section and labels may be defined in the section, but the 
  assembler shouldn't output the text to the object file. This kind of 
  section might be for some device registers or scratch ram located in 
  the target system memory space. The OUT and NOOUT arguments select 
  whether or not the text is placed in the object file. The default for
  all assemblers is OUT. Label definitions are not affected by this 
  argument. 
  </p>
    <p>
  A section may be declared as read-only and read-write on some target 
  systems. The RO and RW arguments identify the section as read-only or
  read-write respectively. A section can be only RO or RW but not both.
  The default for all assemblers is RW. This information is not used by 
  the assembler, it is merely passed through to LLF which may choose to 
  ignore it too or pass it through to an image loader if required.
  </p>
    <p>
  The text that is placed in a section may have certain alignment 
  constraints. For example, the 680x0 must have words and longwords 
  aligned on even byte boundaries and ASAP must have everything except 
  bytes aligned on longword boundaries. The assembler can notify the 
  programmer if these alignment rules are not followed as well as fixing 
  the alignments when so instructed. In order to do this, the alignment 
  rules must be established ahead of time. This is done with the DATA and
  SEGMENT arguments. Each takes an expression which must resolve to a 
  value between 0 and 31 corresponding to a power of two that represents 
  the alignment. The SEGMENT value is used by LLF to position the entire 
  section on an appropriate boundary and DATA is used by the assembler to 
  position text within the section appropriately. The alignment value for 
  SEGMENT must be greater than or equal to the alignment value for DATA.
  (If not, then LLF could align the section to a boundary which may 
  violate the required DATA alignment). The defaults are as follows:
    </p>
    <pre>
    MAC65: DATA=0,SEGMENT=0
    MAC68K: DATA=1,SEGMENT=1
    MACAS: DATA=2,SEGMENT=2
    </pre>
  <p>
  The maximum length to which a section may grow may also be specified.
  The assembler will check that the section does not exceed this limit as
  well as passing the maximum length along to LLF which will use it to
  verify that the length is not exceeded after all like named sections are
  merged together. The argument MAX_LENGTH=n sets this value where n is an
  expression resolving to an absolute value indicating the maximum length
  in bytes of the named section. The default for all assemblers is no
  maximum. Base pages in MAC65 inherit a maximum length of 255. 
  </p>
    <p>
  The first time a .PSECT directive is encountered with a unique name, it
  creates the named section and sets all the attributes for that section.
  Subsequent occurrences of a .PSECT directive for a given section name
  cannot change any of the attributes. As a result, sections should be
  defined early in the assembly and referenced thereafter with a ".PSECT
  section_name" without any arguments. 
  </p>
    <p>
  There are two pre-defined sections: .REL. and .ABS. for the "unnamed"
  relocatable section and the absolute section respectively. The location
  counter is initialized to the start of the .REL. section. One can use
  a .PSECT directive with no name or arguments to set the location 
  counter to the unnamed program section or use a .PSECT .REL..
  </p>
    <p>
  Each section has it own private location counter which is initialized to
  the beginning of the section (offset 0). The location counter is
  incremented as text is placed in the section or otherwise moved with
  pseudo-ops or ".=nn". When a .PSECT directive is encountered, the current location
  counter is saved with the previous section statistics and the location
  counter last used in the new section becomes the current location
  counter. 
  </p>
    <p>
  LLF will complain if like named psects in different modules don't have
  EXACTLY the same attributes. Examples:
    </p>
  <pre>
      .PSECT A,ABS,MAX=16	;section A is absolute
      .PSECT R,REL,OVR    ;section R is relocatable and overlayed
      .PSECT IMPURE       ;defaults to REL,CON,RW
      .PSECT PURE,RO      ;make read-only section
      .PSECT PAGE,DATA=3,SEG=9 ;align section to 512 byte, data to 8 byte
      .word test,...      ;put in some text
      .PSECT IMPURE       ;change sections
      .word text,...      ;put text in different section
      .PSECT PAGE         ;change back to old section
  </pre>
  <h3 id="dir_radix">.RADIX</h3>
  <pre>  
      .RADIX expression
  </pre>
  <p>
  Numbers expressed in the assembly source are assumed to be hexadecimal by default.
  The global radix can, however, be changed using the .RADIX psuedo-op.
  The <u>expression</u> operand resolves to an absolute value of one of 2, 8, 10 or 16
  for binary, octal, decimal or hexadecimal respectively. The radix is
  temporarily changed to decimal before the expression is evaluated. If
  the expression resolves to an unacceptable value, the global radix is
  not changed. For example: 
  </p>
    <pre>
      .RADIX 10        ;changes radix to decimal regardless of what
                       ;       it was before
      .RADIX 16        ;change radix to hex
    OLD_RADIX = 10		 ;saves current value of global radix
      .RADIX NEW_VALUE ;set it to a new value
      .RADIX OLD_RADIX ;restore the old value
    </pre>
  <h3 id="dir_rept">.REPT</h3>
  <pre>  
    .REPT count
    macro_body
    .ENDR
  </pre>
  <p>
  The .REPT directive defines an indefinite repeat block, which is simply
  a macro definition with no arguments followed with an immediate and
  automatic macro call (see details about macros <a href="#dir_macros">HERE</a>). The macro
  is expanded if the count is greater than 0 and the count is decremented
  with each iteration. The <u>count</u> operand is an expression that resolves to an absolute value
  representing the number of times the macro_body is to be expanded and
  macro_body is zero or more lines of assembly code constructed with the
  same rules as for a macro definition. Indefinite repeat blocks may be
  used anywhere a macro may be used. The count is tested at the top of 
  each loop and, if greater than 0, the macro_body is assembled and the
  count is decremented. A .MEXIT or .REXIT executed in the macro_body
  will force the repeat block to skip to the end. A .MEXIT 1 (or more)
  will force the repeat block to exit completely. Examples: 
  <p>
    <pre>
    tmp = 0
      .REPT 16.
      .byte tmp+0,tmp+1,tmp+2,tmp+3
    tmp = tmp + 4
      .endr
    </pre>
  <p>
  would output 64 bytes (16*4) whose values would range from 0 to 63.
    </p>
  <h3 id="dir_restore">.RESTORE</h3>
  <pre>  
    .RESTORE
  </pre>
    <p>
  Restores the location counter and local symbol block from a previous 
  .SAVE directive. See <a href="#dir_save">.SAVE</a> for additional details.
  <h3 id="dir_rexit">.REXIT</h3>
  <pre>  
  .REXIT
  </pre>
    <p>
  The .REXIT directive is an implementation of an alternate exit from a
  repeat block (.IRP, .IRPC or .REPT). Upon encountering a .REXIT
  directive during a repeat block expansion (not during a definition), the
  repeat block is immediately terminated as though it were an .ENDR. This
  is particularly useful in complex conditional structures in that it is a
  functional equivalent to a "goto end_of_repeat_block". This directive is
  ignored outside a macro or repeat block.
  </p>
  <h3 id="dir_save">.SAVE</h3>
  <pre>    
  .SAVE
  </pre>
    <p>
  The .SAVE directive saves the current program section context and local 
  symbol block details on an internal stack. The internal stack is 32
  elements deep. This directive can be used whenever one wants to change
  program sections but needs to be able to restore the section without 
  knowing the name of the current section. This is the most useful in
  macros. For example:
  </p>
    <pre>
      .MACRO SAY MSG       ;general message macro
      .SAVE                ;save the current location counter/section
      .PSECT ASCII         ;switch to section ASCII
    ...1 = .               ;get location of text message
      .ASCIZ \MSG\         ;insert message in the ASCII section
      .RESTORE             ;back to main section (whatever that is)
      PRINT #...1          ;display message
      .ENDM
      
      SAY &lt;This is a test of the .SAVE directive&gt; ;say message
    </pre>
    <p>
  The local symbol block (LSB) is saved as well. Even though a new LSB
  would be opened if there's an intervening label or the program
  section is changed, when the .RESTORE is encountered, the original local
  symbol block is also restored. For example: 
  </p>
    <pre>
      10$:          ;mark the start
        .SAVE       ;save the current loc and lsb
        .PSECT T    ;change sections
      10$:          ;this is a different lsb, since the
                    ;   section changed
        .RESTORE    ;restore section
        .WORD 10$   ;references the FIRST 10$ since the
                    ;   lsb is restored as well as the
                    ;      location counter
    </pre>
  <p>  
  Beware of .SAVE'ing the current section and not doing a .PSECT to a
  DIFFERENT section before adding code or data then doing a .RESTORE
  since that has the effect of moving the location counter backwards.
  For example:
  </p>
    <pre>
        .PSECT CODE       ;say we're in the code section
      FRED:	.SAVE         ;save location of FRED
        .PSECT CODE       ;this is a no-op since we're already
                          ;  in section CODE
        .WORD 1,2,3       ;inserting TEXT
        .RESTORE          ;resets location counter back to FRED
        .WORD 4,5,6       ;will overwrite the 1,2,3 above
    </pre>
  <h3 id="dir_sbttl">.SBTTL</h3>
    <pre>
    .SBTTL text_of_subtitle_message	[;comments]
    </pre>
  <p>  
  Establishes a string to use as a subtitle which is placed on the second
  line of each page in the listing. The first line of each page in the
  listing file contains the title line. The string is for information only
  and is not used by the assembler. This directive is ignored if no
  listing file is being created.
  </p>  
  <h3 id="dir_test">.TEST</h3>
  <pre>
      .TEST expression  ;message to be reported if expression is true
                        ^ <u>Note</u>: the semicolon is required
  
  </pre>
    <p>
  The .TEST directive allows one to pass an expression to LLF to evaluate and
  report an error if the condition is true. If the expression can be evaluated by
  the assembler (i.e. no complex terms) and it evaluates true (true = not zero),
  then the assembler will report the error. This function is much more useful in
  MACAS, MACPP and MAC68K since those assemblers have relational operators (eq,lt,
  gt, etc), however, it is built in to the core assembler so one can have it if one
  can use it. The <u>expression</u> is what is to be evaluated or pass to LLF and the 
  comments are the text of the error message to be displayed if the 
  expression resolves to TRUE (non-zero). Example:
  </p>
    <pre>
      .GLOBL  TEMP                 ;declare an external variable
      .TEST !(TEMP>0 && TEMP&lt;0x10) ;PROG: TEMP should be 0-0x0F
    </pre>
  <p>  
  In this example since TEMP is a global symbol, the expression will be
  evaluated by LLF. The comment field is the text of the message 
  displayed if the expression evaluates true, so the comment should have 
  meaningful information in it such as the program name and/or variable(s)
  involved, etc.
  </p>
  <h3 id="dir_title">.TITLE</h3>
  <pre>  
    .TITLE text_of_title_message	[;comments]
  </pre>
    <p>
  Establishes a string to use as the program title which is placed on the 
  first line of each page in the listing. The text is for information 
  only and is not used by the assembler. This directive is ignored if no
  listing file is being created.
  <h3 id="dir_undefine">.UNDEFINE</h3>
    <pre>
    .UNDEFINE [symbol[,symbol[,...]]]
    </pre>
  <p>
  The .UNDEFINE directive removes the assignment of a previously 
  .DEFINE'd symbol or, optionally, all previously .DEFINE'd symbols.
  The <u>symbol</u> operand represents the symbol to undefine. No error is displayed if
  the symbol has not previously been .DEFINED. If no <u>symbol</u> name is
  supplied, then all symbols previously .DEFINE'd will be de-assigned.
  Example:
  </p>
    <pre>
      .DEFINE FRED A+B   ;assign string to FRED
      .WORD FRED         ;use FRED
      .UNDEFINE FRED     ;deassign FRED
      .UNDEFINE          ;deassign all symbols
    </pre>
  <h3 id="dir_vctrs">.VCTRS</h3>
  <pre>  
    .VCTRS address [,] data [, ...]
  </pre>
    <p>
  This is a short cut directive to allow one to insert 16 bit words at a 
  specified non-relocatable location in the target memory. This 
  directive is not recommended for any assembler except MAC65 where it
  may be used in simple applications. It exists mainly to insert the 
  program vector table for the 6502 at 0xFFFx without the overhead of 
  establishing a program section and having LLF position it accordingly.
  The <u>address</u>is an expression resolving to an absolute value 
  representing where the first byte of data should be placed and data is 
  0 or more expressions (which may be global and/or relocatable) which will placed in 
  the target memory as 16 bit words. The data expressions are interpreted 
  exactly the same as they would be on a .WORD directive. The directive 
  functions as though the following separate statements were executed:
  </p>
    <pre>
      .SAVE            ;save current location counter
      .PSECT .ABS.     ;switch to the absolute section
      .=address        ;set the location counter to the desired value
      .WORD data,...   ;insert the data
      .RESTORE         ;restore the previous location counter
    </pre>
  <p>
  with the exception that the size of the .ABS. section is not changed to
  reflect the event. An example:
  </p>
    <pre>
      .VCTRS 0xFFF8,FIRQ,NMI,RESET,IRQ
    </pre>
  <h3 id="dir_warn">.WARN</h3>
  <pre>
    .WARN [[expression] [;comments]]
  </pre>
  This directive generates a warning and computes and displays the value 
  of the optional expression. It is useful if included in macros or 
  conditionals to force a warning if desired conditions are not met.
  Being that it generates a warning, the whole statement will be displayed
  in the list file and on standard error, so the comments can best be
  used to describe the reason for the error.
  </p>
  <h3 id="dir_word">.WORD and DC.W</h3>
    <pre>
      .WORD [expression[,...]]  [;comments]
      DC.W	(same as .WORD)
    </pre>
  <p>  
  Places one or more 16 bit words in the object file.
  </p>
    <p>
  See <a href="#dir_byte">.BYTE</a> for additional details.
  </p>
  <h2 id="gen_macros">Macros</h2>
  <p>
  Macros are a mechanism whereby a user can have several lines of
  assembly code envoked with a single statement. This is done by defining 
  a macro as a series of one or more assembler statements and giving
  the macro a name. The name of the macro is inserted in the opcode
  symbol table so when that name is used as an opcode, the assembler
  will insert the line(s) of code making up the definition into the 
  source sequence. It is similar in concept to an "in-line subroutine". 
  As in a subroutine, the macro system also allows for the passing of
  arguments. When a macro is defined, a list of arguments is identified
  by name each of which will be replaced by a corresponding argument 
  occupying the same relative position on the macro call as on the macro 
  definition. Typically the arguments are treated as strings and inserted 
  into the expanded macro code at the appropriate place(s), however, the 
  argument may also be passed as a value or as an automatically generated 
  symbol. In addition, the arguments may be declared to inherit default 
  values should they be omitted on the macro call and/or the arguments 
  may be set by keyword value rather than by placement.
  </p>
  <h3>Macro definitions</h3>
  <pre>  
    .MACRO name [,] dummy_argument_list [;comment]
    macro_body
    .ENDM
  </pre>
    <p>
  General macros are defined with the .MACRO directive and the special 
  case repeat block macros are defined with the .IRP, .IRPC and .REPT 
  directives. The <u>name</u> is the name of the macro. It is inserted
  in the opcode symbol table so will be called up when the name is
  used in the opcode field of an assembler statement. The <u>dummy_argument_list</u>
  is a list of zero or more legal assembler text symbols separated with white space
  or commas which may appear anywhere in the macro_body. The <u>macro_body</u>
  is any number of assembler statements. NOTE: There is no specific limit on
      the length of the dummy_argument text. In other words, there is no relation
      to the max symbol or opcode length's assigned at startup. However, the length
      of the macro's name is contrained by the opcode_length specified at startup.
  </p>
    <p>
  Macro names replace whatever is in the opcode symbol table, so one can
  use macros to redefine opcodes. Deleting a macro that replaced an opcode
  causes the old opcode to be restored.
  </p>
    <p>
  The symbols appearing in the dummy argument list only mark places in the
  macro_body where the corresponding argument on the macro call should be
  placed. They do not have any relation to other symbols or labels or
  dummy arguments in other macros (unless it's a nested macro definition)
  so do not have to be unique in that respect. You may decide to choose a 
  name for a dummy argument that has something to do with its function 
  which would make it a bit easier to use the "pass argument by keyword"
  feature (described <a href="#gen_macro_keyword">HERE</a>).
  </p>
    <p>
  The macro body is checked only for .MACRO, .IRP, .IRPC, .REPT, .ENDR
  and .ENDM directives in the opcode field and the presence of dummy
  arguments anywhere in the macro body. No syntax checking is done at 
  all on any data in the macro until the macro is called. As a result,
  DO NOT use the symbols .MACRO, .ENDM, .ENDR, .REPT, .IRP and .IRPC as
  dummy argument names. 
  </p>  
    <p>
  Macro definitions may be nested. That is to say a macro may be created 
  to create other macros which may create other macros etc. to any depth.
  The inner macros, however, won't actually be defined until the outer macros are
  called.
  </p>
  <h3 id="gen_macro_syntax">Macro definition argument syntax</h3>
  <p>
  Dummy arguments appearing on the .MACRO directive are separated from 
  one another and the macro name by commas or white space.
  </p>
  Dummy arguments appearing in the macro body are delimited by any
  character not legal for a symbol or label. If the dummy argument appears
  embedded within or connected to an otherwise legal symbol or label, it
  will not be recognized as a dummy argument. If one desires to cause the
  argument to be prefixed, appended or inserted in the middle of an
  otherwise legal symbol name, the dummy argument may be separated from
  the non-argument text (of any kind) with an apostrophe. The apostrophe(s)
  will be stripped and the argument substitution will occur with no other
  surrounding characters changed. If an apostrophe is required to remain
  in the substituted text, you will need to have two of them. For example: 
  </p>
    <pre>
      .MACRO TST ARG1
      ARG1            ;no apostrophes required
      PRE+ARG1+POST   ;here either
      PRE'ARG1'POST   ;if called with TST T, expands to PRETPOST
      'ARG1'POST      ;leading apostrophe is optional
      PRE'ARG1'       ;trailing apostrophe is optional
      ''ARG1'AFTER    ;if called with TST T, expands to 'TAFTER
      'FOOBAR'        ;apostrophes are only removed when
                      ;   surrounding dummy arguments.
                      ;   So a TST T expands to 'FOOBAR'.
      .ENDM
    </pre>
  <p>
  There is an optional feature with dummy arguments that instructs the
  assembler to assign a default string to that argument if the macro is
  called with the given argument blank. This is done by putting the
  default string following an equal sign appended to the dummy argument on
  the .MACRO statement. If the default string contains commas or spaces,
  it can be enclosed in macro argument delimiters (normally &lt;&gt;'s). For
  example: 
  </p>  
    <pre>
      .MACRO FRED ARG1,ARG2,ARG3=0x1000,ARG4=&lt;1,2,3&gt;
      ARG1 ARG2,ARG3 &lt;ARG4;&gt;
      .ENDM
    </pre>
  <p>  
  defines the macro FRED with 4 arguments. The dummy arguments ARG1, ARG2,
  ARG3 and ARG4 will be replaced with corresponding arguments when FRED is
  called. If ARG3 is left blank on the call, the string 0x1000 will be
  used. If ARG4 is left blank on the call, the string "1,2,3" will be
  used. Using the above defined macro: 
  </p>  
  <table style="width: 25%">
    <tr><th>Macro Call</th><th>Expands to</th></tr>
    <tr><td>FRED ONE TWO THREE</td><td>ONE TWO,THREE &lt;1,2,3&gt;</td></tr>
    <tr><td>FRED ONE TWO,,FOO</td><td>ONE TWO,0x1000 &lt;FOO&gt;</td></tr>
    <tr><td>FRED ONE TWO</td><td>ONE TWO,0x1000 &lt;1,2,3&gt;</td></tr>
    <tr><td>FRED ONE</td><td>ONE ,0x1000 &lt;1,2,3&gt;</td></tr>
    <tr><td>FRED</td><td>,0x1000 &lt;1,2,3&gt;</td></tr>
  </table>  
    <p id="gen_macro_question">
  There is a special type of dummy argument that is identified with a
  leading question mark. This indicates that, when the macro is called and
  the argument is left blank, the dummy argument should be replaced with
  an automatically generated local symbol. These automatically generated
  local symbols are numbered starting with 65000$. Note that the symbol
  does not automatically become a label. You need to use the argument as a
  label somewhere in the macro body in order for the local symbol to
  become a local label. No default value may be assigned to an argument of
  this type. For example: 
  </p>
    <pre>
      .MACRO MAKSYM SOMETHING,?OPT_LABEL
      ...
    OPT_LABEL: 
      SOMETHING
      ...
      .ENDM
    </pre>
  <table style="width: 25%">
    <tr><th>Macro Call</th><th>Expands to</th></tr>
    <tr><td>MAKSYM FRED</td><td>65000$:	FRED</td></tr>
    <tr><td>MAKSYM FOOBAR</td><td>65001$:	FOOBAR</td></tr>
    <tr><td>MAKSYM NOP,MY_LABEL</td><td>MY_LABEL: NOP</td></tr>
  </table>
  <p>
  There are a maximum of 124 arguments allowed in a macro definition.
  </p>
    <p>
  The only pseudo-ops recognized in the macro body are other macro
  definition directives (.MACRO, .IRP, .IRPC and .REPT) and the macro
  termination directives .ENDM and .ENDR. Macro definitions may be nested,
  therefore there must be a matching terminator (.ENDR or .ENDM) for each
  macro definition directive. The outer most termination completes the
  definition. Macros are always stored in memory as are symbols and the
  intermediate object file (if /WORK_FILE is not selected on the command
  line) so they will be limited in size and quantity to the amount of memory
  available to the assembler. If a macro is defined that has the same name
  as a previously defined macro, the old one is deleted from memory and
  replaced with the new one.
  </p>
  <h3 id="gen_macro_calls">Macro calls</h3>
    <pre>
      [label:]  .MACRO name [real_arguments]	[;comments]
    </pre>
  <p>
  A macro must be defined prior to its first reference. The <u>label</u>
    represents an optional label. The <u>name</u> represents the name
    of the macro and is the first argument on the .MACRO directive,
    <u>real_arguments</u> are 0 or more symbols, expressions, and/or values
     separated by commas or white space which replace the dummy arguments as found in the
      .MACRO definition. The <u>comments</u> are normal optional comments.
      </p>
  <p>
  Arguments to a macro call are treated as character strings whose usage
  is determined by the statements appearing in the macro definition with
  one exception as described below. If white space or commas appear in a
  macro argument, the argument must be enclosed between a pair of macro
  argument delimiters (normally &lt;&gt;'s). For example given the macro FRED:
  </p>
    <pre>
      .MACRO FRED ARG1,ARG2,ARG3=0x1000
      ARG1 ARG2,ARG3
      .ENDM
    </pre>
  <p>  
  the call of:
  </p>
    <pre>
      FRED &lt;.WORD ONE,TWO&gt;,THREE,FOUR
    </pre>
  <p>  
  expands to
  </p>
    <pre>
      .WORD ONE,TWO THREE,FOUR 
    </pre>
  <p>  
  The up-arrow construct may be used to change the argument delimiters
  locally if desired. For example the following is equivalent to the
  example above:
  </p>
    <pre>
      FRED ^\.WORD ONE,TWO\,THREE,FOUR
    </pre>
    
  <h3 id="gen_macro_call_arguments">Macro call arguments</h3>
  <pre>  
    .MACRO FOO ARG1 ARG2
    ARG1 ARG2
    .ENDM
  </pre>
    <p>
  Arguments on a macro call are separated from other arguments by commas
  or white space. Arguments which contain commas or white space must be
  enclosed in paired macro delimiters (normally &lt;&gt;'s). An up-arrow
  construct may be used to change the delimiter characters on an
  individual argument. This would be useful if the argument contains
  argument delimiter characters itself. For example, given the macro
  definition. For example one could call it with:
    </p>
    <pre>
      FOO &lt;ADD #24,&gt; ANSWER	;or
      FOO ^/ADD #24,/ ANSWER	;the equivalent call
    </pre>
  <p>  
  both of which would expand to:
  </p>
    <pre>
      ADD #24, ANSWER
    </pre>
  <p>  
  The macro argument delimiters are removed from the argument as the
  dummy argument substitution is made. As noted above, the &lt;&gt;'s and the
  ^/'s do not appear in the final expansion. This should be particularly
  significant during macro nesting. For example, one could recursively
  call the macro FOO as defined above with:
  </p>
    <pre>
      FOO &lt;FOO &lt;ADD #24,&gt;&gt; ANSWER
    </pre>
    <p>
  expands to:
    </p>
    <pre>
      FOO &lt;ADD #24,&gt; ANSWER
    </pre>
    <p>
  and that expands to:
    </p>
    <pre>
      ADD #24, ANSWER
    </pre>
  <p>  
  Note that with each expansion, one level of &lt;&gt;'s have been removed 
  from  the argument.
  </p>  
    <p id="gen_macro_keyword">
  Arguments are normally delivered to macros by placement. That is, the
  first argument after the name on a macro call replaces the first dummy
  argument in the macro body. The second replaces the second dummy
  argument, etc. Arguments may also be delivered to a macro in a macro
  call by way of keywords. That is, an argument may be identified by its
  dummy argument name instead of by placement. This is done by prefixing
  the real argument value with the dummy argument name followed by an
  equal sign. All the arguments that are identified by keywords are
  assigned first. Then, if there are any additional arguments, they are
  assigned positionally to any dummy arguments that haven't yet been
  assigned. For example, given the macro definition: 
  </p>
    <pre>
      .MACRO FOOBAR A,B,C,X,Y,Z
      .WORD A,B,C,X,Y,Z
      .ENDM
    </pre>
  <p>  
  The macro call:
  </p>
    <pre>
      FOOBAR 1,2,3,4,X=5,A=6
    </pre>
  <p>  
  expands to
  </p>
  <pre>
            _________________ Dummy argument A gets value "6"
            |     ___________ Dummy argument X gets value "5"
            |     |
            v     v
      .WORD 6,1,2,5,3,4
              ^ ^   ^ ^
              L_L___L_L______ Other arguments get what's left in order
  </pre>
    <h4 id="gen_macro_generated_argument">Macro generated argument</h4>
    <pre>
      macro_call [...args...] \absolute_expression [...args...]
    </pre>
  <p>
  Normally, arguments on a macro call are treated as simple strings and
  substituted for dummy arguments unchanged into the macro body. There is
  another special type of macro call argument which can be used which is a
  pass by value. In this case the argument must be an expression that
  resolves to an absolute value and the expression must be prefixed
  with a backslash character (\). With this construct, the expression is 
  evaluated and the value is converted to ASCII in the current default radix.
  This ASCII string is what gets substituted for the dummy argument. You 
  may also specify the radix for the conversion by using a double backslash
  followed by one of O, D, H or X for octal, decimal, hexadecimal or 
  hexadecimal respectively. Some examples: 
  </p>
    <pre>
      .RADIX 10		;decimal radix
      FRED=400
      .MACRO GENVAL val
      .word vtst'val,val
      .endm
    </pre>
  <table style="width: 25%">
    <tr><th>Called</th><th>Expands to</th></tr>
    <tr><td>GENVAL \FRED*4</td><td>.word vtst1600,1600</td></tr>
    <tr><td>GENVAL \FRED/2</td><td>.word vtst200,200</td></tr>
    <tr><td>GENVAL \\XFRED/2</td><td>.word vtst0C8,0C8</td></tr>
  </table>  
  <h2 id="gen_operating">Operating Instructions</h2>
  <p>
  This assembler has been ported to and the appropriate version will
  run on VAX/VMS(tm), MS-DOS(tm), SCO Xenix/386(tm), SCO Unix(tm),
  GEM-DOS (Atari/ST) and Linux. The command line syntax is the same for all 
  versions with the exception that the option delimiter on Xenix/Unix/Linux
  is a dash character (-) instead of the slash character (/). In addition,
  the Xenix/Unix/Linux option(s) must be preceeded with white space since the 
  dash is a legitimate filename character. And the image name, although not
    required to be, is typically lowercase on Xenix/Unix/Linux systems.
    The general form is:
  </p>
    <pre>
      MACxx file(s)... [options...]
      MACxx [options...] file(s)...
      MACxx [options...] file(s)... [options...]
    </pre>
  <p>  
  where <u>MACxx</u> is the name of the program (MACPP, MAC65, MAC68, MAC68K, MAC682K, MAC69, MAC11, MACAS or MACTJ),
  <u>file(s)</u> represents one or more files separated with whitespace or 
  commas and options represents one of the options itemized below. The 
  options and filenames can appear on the command line in any order.
  Whitespace must separate an option from a filename following it but is 
  otherwise optional except on Xenix/Unix systems where white space must
  separate filenames and options from one another. Commas are treated
  as whitespace. The text of the option can be abbreviated to the fewest
      number of characters that will make it unique. The valid options are:
  <p>
  <table style="width: 50%">
    <tr><th>Option</th><th>Default</th><th>Meaning</th></tr>
    <tr><td>2_PASS</td><td>No</td><td>All except MACPP; Assembler becomes a 2.5 pass instead of the normal 1.5 pass.</td></tr>
    <tr><td>ABBREV</td><td>No</td><td>Abbreviate the error messages</td></tr>
    <tr><td>ASSEM="string"</td><td>No</td><td><u>string</u> is a line to be assembled before anything else. Any number of these may be used</td></tr>
    <tr><td>BINARY</td><td>No</td><td>Create output object file in binary format (selects filetype of .ob)</td></tr>
    <tr><td>BOFF</td><td>Yes</td><td>MACAS only; Include a branch offset test in the output.</td></tr>
    <tr><td>DEBUG</td><td>No</td><td>Places source code debug information in the object file.</td></tr>
    <tr><td>GREENHILLS</td><td>No</td><td>MAC68K and MAC682K only; selects the instruction syntax output by the Greenhills C compiler</td></tr>
    <tr><td>IDE_SYNTAX</td><td>No</td><td>Sets output format of any error messages such that they may be interpreted by an Integrated Development Environment.</td></tr>
    <tr><td>IGNORE</td><td>No</td><td>Ignore errors on lines having unsupported assembler directives.</td></tr>
    <tr><td>INCLUDE=path</td><td>No</td><td>Set a <u>path</u> to look for .INCLUDE'd files (any number of these may be used)</td></tr>
    <tr><td>JERRY</td><td>No</td><td>MACTJ only; Includes opcodes for the Atari Jerry DSP. If not present, it includes opcodes for the Atari Tom DSP.</td></tr>
    <tr><td>LIST</td><td>No</td><td>Create a listing output file</td></tr>
    <tr><td>LIST=name</td><td>No</td><td>Create a listing output file with <u>name</u>[.lis]</td></tr>
    <tr><td>MISER</td><td>Yes</td><td>Assembler it miserly about using memory.</td></tr>
    <tr><td>OCTAL</td><td>varies</td><td>Display numbers in octal in the listing file.</td></tr>
    <tr><td>OPCODE_LEN=n</td><td>varies</td><td>Sets the significant length of the opcodes and macros to <u>n</u>. <u>n</u> may be a value between 6 and 32</td></tr>
    <tr><td>OUTPUT</td><td>Yes</td><td>Create an output object file</td></tr>
    <tr><td>OUTPUT=name</td><td>No</td><td>Create an output object file with <u>name</u>[.ol] or <u>name</u>[.ob]</td></tr>
    <tr><td>RELATIVE</td><td>Yes</td><td>Output object file is relative.</td></tr>
    <tr><td>SQUEAK</td><td>No</td><td>Output diagnostic messages.</td></tr>
    <tr><td>SYMBOL_LEN=n</td><td>varies</td><td>Sets the significant length of the symbols and labels to <u>n</u>. <u>n</u> may be a value between 6 and 32</td></tr>
    <tr><td>TEMPFILE</td><td>No</td><td>Use temporary file to hold intermediate object file</td></tr>
    <tr><td>TEMPFILE=name</td><td>No</td><td>Use temporary file <u>name</u> to hold intermediate object file</td></tr>
  </table>  
    <p>
  NOTE: On Xenix/Unix/Linux systems, the option delimiter is a dash (-).
  </p>
    <p>
    All the options that have a default of <u>Yes</u> can have a prefix of <u><b>NO</b></u> to indicate the option is not wanted.
    </p>
    <p>
  The case of any option is not significant and they may be abbreviated to
  the least number of characters that prevents ambiguity. 
  </p>
    <p>
  NOTE: If the filename is omitted from the OUT or LIS options, then a default filename is created
    from the basename of the first input file with either a .OB or .OL appeneded on the object file
    and a .LIS appended on a listing file respectively. For examnple:
    </p>
    <pre>
    mac65 -lis -out foo,fred
    </pre>
    <p>
    Will produce a foo.ol and foo.lis file.
    </p>
    <p>
    The SYMBOL_LEN and OPCODE_LEN options default to different numbers on different assemblers. Both lengths default to the same number
    according to this table:
    </p>
  <table style="width: 20%">
    <tr><th>Assembler</th><th>Default</th></tr>
    <tr><td>MAC65</td><td>6</td></tr>
    <tr><td>MAC68</td><td>6</td></tr>
    <tr><td>MAC69</td><td>6</td></tr>
    <tr><td>MAC68K</td><td>16</td></tr>
    <tr><td>MAC682K</td><td>16</td></tr>
    <tr><td>MAC11</td><td>16</td></tr>
    <tr><td>MACAS</td><td>16</td></tr>
    <tr><td>MACTJ</td><td>16</td></tr>
    <tr><td>MACPP</td><td>32</td></tr>
  </table>
    <p>
  Examples:
    </p>
  <pre>  
      MAC65 FOOBAR/LIS     !outputs are FOOBAR.OL and FOOBAR.LIS 
      MAC65 FUBAR/NOBIN    !output is FUBAR.OL
      MAC65 FUBAR/BIN      !output is FUBAR.OB
      mac65 foobar -lis    !on Unix/Linux...
      mac65 -lis foobar    !...options can be anywhere
      MACAS HEADER,FOO,BAR/LIS=TEST/OUT=FOO/DEBUG/SYM=16
                           !   ...files HEADER, FOO and BAR are
                           !   ...assembled in order; the outputs
                           !   ...are FOO.OL and TEST.LIS
                           !   ...FOO.OL has debug records in it
                           !   ...symbol/labels are significant to 16
                           !   ...characters.
      mac65 -assem="VAR1=100" -ass="VAR2=200" -inc=hdrs file1.mac file2
      macpp -out=new.mac -lis old.mac
  </pre>
<h2>Appendex</h2>
    <h3 id="macxx_specials">
    <p>
    <em>NOTE: If you find yourself wanting to use mac65, mac68 or mac69 to build old Atari coin-op games, at least those
    that included HLL6xF.MAC in their sources, you will find the source does not assemble without error in the default
    1.5 pass mode. Instead you will need to either use the -2_PASS command line option (the simplest method but
    only available with macxx version 11.xx or later) or replace the HLL6xF.mac in your source kit with the example hll65f.mac
    file included in the sources with the macxx kit AND, in the specific case of HLL65F.MAC, set the variable CMAC65=1 somewhere.
    I.e. add the command line: <b>-assem=CMAC65=1</b> or just edit hll65f.mac and set it to 1 permanently.<br>
    And pay attention to filename case. On *nix systems there will be trouble with the automatic add of
    lowercase .mac to files <b>.INCLUDE</b>d in game sources.<br>
    </p>
    <p>NOTE: Also note the assembler will first try to open a .mac file and
      if that doesn't work, it will try to open a .MAC file.
    </em>
    </p>
    </h3>
    <h3 id="mac65_specials">MAC65 special psuedo-ops, operations and address modes</h3>
    <p>
    MAC65 has a bit of history at Atari. See more details in the <a href="#history">HISTORY</a>
    section about this if one cares.
    The only tool available in 1975 to the microprocessor developers (all two of them) was
    the RT11 MACRO-11 assembler running on their PDP11/05 computer. They used this tool
    to assemble for the first 6502 and 6800 game boards by writing macros for all the 6502 and 6800 opcodes.
    They specified the address mode, if required, as the first of two operands to the macro. This is
    opposite of what was specified in the MOS technology manual.
    </p>
    <p id="M65_Addressing">
    For example, to select absolute address mode on a LDA, the operand would be A so the instruction would
    appear in the source as:
    </p>
    <pre>
    LDA A,addr ;comment
    </pre>
    <p>
    Likewise for all the others, Z for base page, ZX for base page indexed by X, etc. I have no
    idea why they chose that over what was in the MOS Technology 6502 manual which basically has
    the two operands reversed.
    Through 1975, 1976 and some of 1977 this was the M.O. of all of us game programmers
    at Atari (coin-op at least). If one sees this kind of syntax in any of the old Atari 6502 code,
    at least for coin-op games, that is the reason. Many programmers continued to use
    that syntax throughout their career at Atari despite my subsequently having made an alternate syntax
    available. Here are all of the old syntax Mac65 will accept (I think):
    </p>
    <pre>
    opc A,addr     ;absolute (16 bit address)
    opc AX,addr    ;absolute indexed by X (16 bit address)
    opc AY,addr    ;absolute indexed by Y (16 bit address)
    opc I,imm      ;load immediate (8 bit immediate)
    opc            ;operand implied (i.e. RTS, CLC, SEC, ASL, etc.)
    opc N,addr     ;absolute indirect (16 bit address)
    opc AN,addr    ;absolute indirect (16 bit address; same as 'N')
    opc NX,addr    ;indirect indexed by X (8 bit address)
    opc NY,addr    ;index by Y indirect (8 bit address)
    opc Z,addr     ;base page (8 bit address)
    opc ZX,addr    ;base page indexed by X (8 bit address)
    opc rel        ;relative branch (8 bit signed offset)
    opc S,abs      ;relative branch (8 bit signed offset; S means current PC, abs is an absolute signed offset)
                   ;   this exists just for compatibilty. The better syntax would be opc .+/-abs.
    </pre>
    <p>
    NOTE: As a game programmer I was both using the assembler, coding it and adding
    features to it as I wanted and needed. I found having commas as part of operands made
    passing them as arguments to macros being quite problematic or maybe it was just annoying.
    In either case I much preferred combining address mode into the operand without the need for commas.
    Here are the address modes mac65 will accept without needing commas:
    </p>
    <pre>
    opc addr       ;absolute or zero page (assembler will try to figure out whether 8 or 16 bit address)
    opc addr(X)    ;absolute or zero page indexed by X (assembler will try to figure out whether 8 or 16 bit address)
    opc addr(Y)    ;absolute indexed by Y (16 bit address)
    opc #imm       ;load immediate (8 bit immediate)
    opc            ;operand implied (i.e. RTS, CLC, SEC, ASL, etc.)
    opc @addr      ;absolute indirect (16 bit address)
    opc @addr(X)   ;indirect indexed by X (8 bit address)
    opc @addr(Y)   ;index by Y indirect (8 bit address)
    opc rel        ;relative branch (8 bit signed offset)
    </pre>
    <p>
    When <u>.ENABL MOS</u> runtime option or the <u>65816</u> command line option is selected, the accepted syntax changes to that as described in the
    MOS Technology 6502 or Western Design Center 65816 manuals respectively which is a hybrid of the two syntaxes shown above (except the address mode
    follows the operand). Being there are commas in many of them, passing them as arguments to macros can be a bit tricky and troublesome. I believe
    the MOS/WDC syntax is of the form:
    </p>
    <pre>
    opc addr       ;absolute or zero page (assembler will try to figure out whether 8 or 16 bit address)
    opc addr,X     ;absolute indexed by X (assembler will try to figure out whether 8 or 16 bit address)
    opc addr,Y     ;absolute indexed by Y (16 bit address)
    opc #imm       ;load immediate (8 bit immediate)
    opc            ;operand implied (i.e. RTS, CLC, SEC, ASL, LSR, etc.)
    opc A          ;operand is accumulator (i.e. ASL, LSR, etc.)
    opc (addr)     ;absolute indirect (16 bit address)
    opc (addr,X)   ;indirect indexed by X (8 bit address)
    opc (addr),Y   ;index by Y indirect (8 bit address)
    opc [addr,X]   ;65816 only: indirect indexed by X (16 bit address)
    opc [addr],Y   ;65816 only: index by Y indirect (16 bit address)
    opc rel        ;relative branch (8 bit signed offset)
    </pre>
    <p>
    <em>
    NOTE: Atari coin-op never did any development with the 65816 CPU. It was added to mac65 so it could be used should that change.
    The upshot is it was never tested with mac65 so there might be bugs in there somewhere. And to add to that, I don't remember
    what I had in mind on how to specify one wanted 24 bit address modes for the 816 CPU. Good luck with it.
    </em></p>
    <p>
    Mac65 has two command line options unique to it:
    </p>
  <table style="width: 30%">
    <tr><th>Option</th><th>Default</th><th>Meaning</th></tr>
    <tr><td>CMOS</td><td>No</td><td>Selects the instruction set for the 65C02 CMOS processor</td></tr>
    <tr><td>816</td><td>No</td><td>Selects the instruction set for the 65816 processor</td></tr>
  </table>
    <p>
    The <u>CMOS</u> option select the opcodes for the 65C02 processor and the <u>816</u> option selects the opcodes
    for the 65816 processor.
    </p>
    <p>
    The SYMBOL_LENGTH and OPCODE_LENGTH command line options both default to 6 in mac65.
    </p>
    <p></p>
    <h3 id="macpp_specials">MACPP special psuedo-ops and operations</h3>
    <p>
    The MACPP assembler is unique in that it doesn't actually assemble anything or
    produce an object file. Instead it just uses all the macro and conditionals
    available to all the assemblers and is useful to conditionally produce some
    plain text file suitable to use by some other language processor. For example
    it was used at Atari to pre-process some configuration files using very complex
    conditional states and variables and produce both a configuration file that could
    be later used by either macxx, a C compiler or some other language we happened
    to be using at the time. I.e. one common configuration for all applications. The
    PP in MACPP stand for Pre-Processor. Macpp has some unique psuedo-ops and
    command line options:
    </p>
  <table style="width: 50%">
    <tr><th>Option</th><th>Default</th><th>Meaning</th></tr>
    <tr><td>OUTPUT</td><td>Yes</td><td>Create an output object file</td></tr>
    <tr><td>LINE</td><td>No</td><td>Include input line number in output</td></tr>
  </table>
    <p>
    The -LINE command line option directs Macpp to include source line numbers
    in the listing file. If no listing is selected, this option does nothing.
    </p>
    <p>
    Macpp allows one to supply multiple output filenames. The output is directed
    to the appropriate file with a .OUTFILE directive. For example:
    </p>
    <pre>
    macpp -out=file0.mac -out=file1.mac input.mac
    </pre>
    <p>
    The output file number is specified by the order in which they are expressed on the
    command line. In the above example file 0 is the first one, file 1 is the second, etc.
    To change output files the directive <u>.OUTFILE expression</u> is used. For example, the contents of
    the input.mac file as used above could contain something akin to:
    </p>
    <pre>
    This line and all before it go into file 0.
    .outfile 1  ;Switch to the other output file
    This line goes into file 1.
    .outfile 0  ;Switch back to file 0.
    This line continues the output of file 0.
    ...
    </pre>
    <p></p>
    <h3 id="mac68k_specials">MAC68K and MAC682K special psuedo-ops and operations</h3>
    <p>
    The mac68k and mac682k assemblers accept one of two syntaxes. The default syntax matches what the
    GNU 68k assembler uses and, in fact, is what we used at Atari to assemble the output
    of gcc when doing cross-compiles. The alternate syntax is that of what the Greenhills C
    compiler output. That syntax is chosen using the GREENHILLS command line option. I leave
    it as an exercise to the reader to determine what those are. The SYMBOL_LEN and OPCODE_LEN
    command line options default to 16.
    </p>
    <p>
    </p>
    <h3 id="macas_specials">MACAS special psuedo-ops and operations</h3>
    <p>
    The ASAP CPU is a custom designed 32 bit processor designed by Atari coin-op. The acronym stands for Atari
    Simplified Architecture Processor. It was coincidently similar to the MIPS R3k processor but without
    hardware integer multiply and divide and no floating point. I believe our cost for it was around $5 (or
    maybe that was the target; I don't know if we hit it). I do not believe it was ever used in a prodction
    game. We made 100's of little boards for use within engineering to control some game development systems
    and we used those right up until coin-op closed up shop (and even for a few months after). Think of it
    as a kind of Raspberry PI today. I ported Xinu to it and we had all of them hooked up to our Ethernet. The ASAP
    has 32 general registers with register 0 always reading as 0, a 32 bit status register and a 32 bit program counter.
    All instructions are 32 bits wide. I think only the memory read/write operations take two clock cycles
    all the rest are one cycle. And I believe a branch always executes the instruction after the branch whether the
    branch is taken or not. I believe this means it has a one stage pipeline.
    </p>
    <p>
    The macas assembler has a single command line option unique to it: BOFF. That is turned on by default
    and it includes instructions in the object file to LLF to test branch offsets for out of range and if
    found, print the filename and line number of the branch instruction in error. The SYMBOL_LEN and OPCODE_LEN
    command line options default to 16. The address modes follow
    this model syntax:
    </p>
    <pre>
    opc dstReg,src1Reg,src2Reg         ; dstReg &lt;- src1Reg op src2Reg
    opc dstReg,srcReg,constant         ; dstReg &lt;- srcReg op constant
    ld.size dstReg,src1Reg[src2Reg]    ; dstReg &lt;- @(src1Reg + (src2Reg&lt;&lt;size))
    ld.size dstReg,src1Reg[constant]   ; dstReg &lt;- @(src1Reg + (constant&lt;&lt;size))
    st.size srcReg,dst1Reg[dst2Reg]    ; srcReg -&gt; @(dst1Reg + (dst2Reg&lt;&lt;size))
    st.size srcReg,dst1Reg[constant]   ; srcReg -&gt; @(dst1Reg + (constant&lt;&lt;size))
    bcond address                      ; on condition currentPC += (address - currentPC); (-0x800000 &lt;= offset &lt;= 0x800000)
    bsr dstReg,address                 ; dstReg &lt;- currentPC; currentPC += (address - currentPC)
    jsr.size dstReg,src1Reg[src2Reg]   ; dstReg &lt;- currentPC; currentPC &lt;- @(src1Reg + (src2Reg&lt;&lt;size))
    jsr.size dstReg,src1Reg[constant]  ; dstReg &lt;- currentPC; currentPC &lt;- @(src1Reg + (constant&lt;&lt;size))
    getps dstReg                       ; dstReg &lt;- current status register
    putps srcReg                       ; srcReg -&gt; current status register
    </pre>
    <p>
    Where <u>.size</u> on the opcode is one of .B, .W or .L and in the shift count is 0, 1 or 2 respectively.
    </p>
    <p>
    </p>
    <h3 id="mac11_specials">MAC11 special psuedo-ops and operations</h3>
    <p>
    The syntax of this assembler matches that of the default DEC PDP11 MACRO-11 assembler. We shipped some coin-op games
    using the T-11 processor on our SystemII platform. The games were coded using BLISS-16 cross compiled on VAX/VMS with its
    output fed into mac11 then llf'd to get a final output.
    </p>
    <pre>
    opc             ; implied (NOP, CLC, RTI, etc.)
    opc expr        ; branch, trap, etc.
    opc src,dst     ; src and dst described below
    ; Registers are indicated with a <b>%n</b> where the 0&lt;=<b>n</b>&lt;= 7
    ; The register symbols R0-R7 and r0-r7 are preassigned to %0-%7 respectively
    ; SP and sp is preassigned to %6 and PC and pc is preassigned to %7
    ; Rn       = Register
    ; (Rn)     = Register has address
    ; (Rn)+    = Register has address, post fetch auto-increment by 1 or 2
    ; @(Rn)+   = Register has address of address, post fetch auto-increment
    ; -(Rn)    = Pre-fetch auto-decrement by 1 or 2, Register has address
    ; @-(Rn)   = Pre-fetch auto-decrement by 2, register has address of address
    ; idx(Rn)  = Register + idx is address; idx is signed integer
    ; @idx(Rn) = Register + idx is address of address; idx is signed integer
    ; #imm     = Operand follows instruction
    ; @#imm    = Address follows instruction.
    ; rel      = Relative; Instruction address+4+rel is address
    ; @rel     = Indirect relative; Instruction address+4+rel is address of address
    </pre>
    <p>
    </p>
    <h3 id="mactj_specials">MACTJ special psuedo-ops and operations</h3>
    <p>
    Sorry, I don't know anything about the Tom and Jerry DSP. It was a chipset used in one of the early consumer products
    and I can't even tell you what consumer product that was. I believe we in coin-op shipped only one game
    that had this chipset in it: Area-51. Maybe one of its sequels also had them but I doubt it. I personally never
    had any dealings with the chipset and I imagine I made mactj assemble code according to syntax
    defined by the chip developer. I don't remember what that was and have no further information about it.
    </p>
    <p>
    The only unique thing about <b>mactj</b>, is it defaults to assembling code for the TOM chip instruction set. One must use
    the command line option <b>JERRY</b> to include/revert to the JERRY chip instruction set. Otherwise they are the same.
    </p>
  <p>
    </p>
  <h2 id="history">A Little History</h2>
    <!-- <div style="border: 2px solid black;margin:4px;padding: 4px"> -->
    <div>
  <em>
  <p>
    In 1975 when the engineers at Atari were just starting to develop
    game hardware using microprocessors there were no development tools they were willing
    to purchase (surprisingly they were operating on quite the shoestring budget for
    everything at the time).
    They had a second or third hand PDP11/05 computer running RT11 with dual
    8" floppy disks and a paper tape reader/punch and a very cheap keyboard CRT setup
    that could show 12 lines of 80 columns uppercase only text. The RT11 O/S included
    a macro assembler that, by default of course, expected to assemble PDP11 source
    into an RT11 object file to be subsequently linked with the RT11 linker, LINK.
    It might have been, instead of being too cheap to buy them, just simply at the
    time there were no 6502 development tools available for RT11. I don't know.
    In any event What the first programmer did was write macros for each
    of the 6502 instructions (and another set for the 6800 which they were developing with
    at the same time). The address mode was specified as the first argument of the macro and
    the operand as the second argument. Then used MACRO-11 to assemble it to produce an object
    file then that was linked with LINK. The ROM image was clipped out of the result.
  </p>  
    <p>
    I hated it. For two main reasons. The RT11 MACRO-11 assembler
    printed all the numbers in its listing as octal numbers but I (and everybody else) much
    preferred to use hexadecimal with all the microprocessor programming. Add to that MACRO-11
    only accepted as input binary, octal or decimal numbers so hexadecimal wasn't an option for
    either input or output. The first programmer managed a kinda-sorta workaround for output by
    writing a custom RT11 line printer driver that would watch the text going through it and convert
    what it thought were octal numbers into hex. Due to the nature of the beast it made a lot of
    unavoidable mistakes. There was no hope for the link map produced by LINK since all its
    link maps showed all numbers with octal. The first programmers didn't much care about that
    since their game program(s) were a single source module coded with absolute addressing (as were
    both of my first two games I did at Atari).
    </p>
    <p>
     Although I was technically a game programmer, after I finished my very first game at Atari (in mid
     1976), I decided to first fix the link map problem so in my "off hours" (really, no such thing back then
     so it took a while) I wrote a new linker, LINKM. This tool
     basically just printed the link map in hexadecimal but otherwise did everything the same as LINK.
     We limped along with these tools for a year or so then since all the games I'd been working on used
     a 6502, I took upon myself to write a new assembler for it that could take hexidecimal as well
      as binary, octal and decimal as input and spit out listings with hexadecimal. When I mentioned my plans
    to my co-workers, it was suggested I should expand this new assembler to include all the other
    microprocessors we were developing for at the time too: the 6502, 65C02, 6800, 6809, Z80, 8080,
    and, why not, I threw in the PDP11 too. This project became MACXX. I wrote it in PDP11 assembly for
    the RT11 operating system which is all I had at the time. I probably started it around late 1977 or
    early 1978. It must have worked a treat and been just what the doctor ordered. I don't remember.
    </p>
    <p>
    In 1981 we were able to buy our first VAX: A VAX-11/780. We quickly learned one wasn't enough,
    so we got another one and a new building too. That eventually grew to many more Vaxen. Note that
    even though we were using the VAX, it would run PDP11 code (at least the 780 and 750 would) so
    I patched a version of RT11 that would run as a task on the VAX and we continued using the RT11
    LINKM and MACXX tools on it. Sometime in the early 1980's, DEC offered a version of the C compiler
    for the VAX and we got it. I took the opportunity to re-write both MACXX and LINKM in C (I called
    the linker LLF). The C version of MACXX did not include all the same psuedo-ops (nobody was using
    them) and since we stopped using the 6800 by then and never did any development for the Intel processors,
    I didn't port over the 6800, 6809, 8080 or Z80. We had by then switched from using the 6800 to the
    68000 family, so I added modules to assemble for the 68000 and 68010. And making a version
    what was simply a pre-processor was suggested and I thought that a great idea so MACPP was born too.
    Later once coin-op designed its own custom processor, the ASAP, I added a MACAS and consumer had a custom
    DSP chipset (Tom&Jerry) that we used in at least one of our coin-op games, so I added modules to
    assemble for them too. That became MACTJ. I couldn't tell you the order any of those appeared. I just
    don't remember. It never occurred to me to keep release notes on either project.
    </p>
  </em>
  </div>
  </body>
</html>
