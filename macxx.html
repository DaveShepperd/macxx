<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
<!--    <link rel="stylesheet" href="style.css"> -->
    <title>MACXX</title>
  <style>
  table {
    border-collapse: collapse;
    width: 50%;
  }
  
  th, td {
    text-align: left;
    padding: 2px;
  }
  
  tr:nth-child(even) {
    background-color: #D6EEEE;
  }
  .TblCntr table
  {
		margin: 10px;
		border:1px solid #000;
    border-collapse: collapse;
    width: 50%;
    align: left;
  }
  .TblCntr tr
  {
    border: 2px solid white;
  }
  .TblCntr th
  {
    border: 2px solid white;
    text-align: center;
    padding: 2px;
  }
  .TblCntr td
  {
    border: 2px solid white;
    text-align: center;
    padding: 2px;
  }
  .TblCntr tr:nth-child(even)
  {
      background-color: #D6EEEE;
  }
  </style>
  </head>
  <body>
  <div style="width: 25%;text-align:center;">
  <h1>MACXX</h1>
  MACxx Macro Assembler<br>
  Version 10.28<br>
  First created probably late 1977<br>
  Revisions through Nov 1989 on the PDP11 assembly version<br>
  Revisions through Aug 2022	on the C version<br>
  </div>
  <p></p>
  <div style="border: 2px solid black;margin:4px;padding: 4px">
  <em>Note from Dave Shepperd, 8/2022
  <p>
  There never were any release notes kept on this application so there is no record of what got changed when. It just is what it is.
  I wrote the PDP11/RT11 version in the late 1970's and the current C version in the early to mid 1980's. It continued to get development until the late 1990's
    and continues to get bug fixes to this day.
    </p>
    <p>
    Recently I got involved in rebuilding some of old Atari coin-op game code (some of which recently
    released on github) and wanted to use this tool to make ROM/EPROM images to use with MAME. This prompted me to port the documentation to HTML in preparation
    of posting this tool to github too.
    Although I wrote the original documentation (macxx.doc), I am neither a technical writer nor am I any good at HTML5. As might be evidenced
    with the original documentation, I quickly lose interest in writing technical documents and don't check things too closely. So good luck
    making sense of anything written here. Feel free to hack this document into something more readable. If you do, please send me a copy.
  </p>
  </em>
  </div>
  <p>
  MACxx is an assembler first written in PDP11 assembly language for a computer running RT11 (RT11 version 2 or 3, I don't recall which).
  Later it was rewritten in the C language and has been ported to various operating systems. The RT11 version was implemented as a 2 pass
  assembler. The current C version is a 1.5 pass assembler meaning it makes one pass through the source code producing both a listing and
  an intermediate internally maintained binary object "file". Once all the souce has been parsed, it makes another pass through its internally
  maintained object "file" resolving all expressions it is able to and producing the actual binary or ASCII object file.
  </p>
  <p> The macxx sources produce a unique macro assembler for the following processors:
  </p>
  <pre>
  <b>macpp</b>    - A macro pre-processor; no CPU; it works similar to the C language's CPP.
  <b>mac65</b>    - For the MOS Technology 6502 and 65C02 CPU
  <b>mac68k</b>   - For the Motorola 68000 and 68010 CPU
  <b>mac682k</b>  - For the Motorola 68020 CPU
  <b>mac11</b>    - For the PDP11 CPU
  <b>macas</b>    - For the custom Atari Simplified Architecure Processor (ASAP) CPU
  <b>mactj</b>    - For the Atari custom Tom and Jerry CPU
  </pre>
  <p>
  <b>Macxx</b> consists of a core group of pseudo-ops
  common among all versions of the assembler and a common statement syntax. The output of these assemblers
  (except <b>MACPP</b>) is expected to be further processed by <b>LLF</b> into a load image. <b>LLF</b> is
  yet another tool I wrote that is a link+locate+format editor. <b>LLF</b> may be found <a href="some_place_as_yet_defined" target="_blank">HERE</a>.
  </p>
  <h2>Statement syntax</h2>
  <p>
  A source program is composed of a sequence of source lines; each 
  source line contains a single assembly language statement followed by a 
  terminator (line feed or form feed). Input lines are limited to 255
  characters.
  </p>
  <p>
  A statement can contain up to four fields which are identified by order
  of appearance and by specified terminating characters. The general 
  format of a MACxx assembly statement is:
  </p>
  <pre>
      [label:]	[opcode	[operand(s)]]	[;comments]
  </pre>
  <p>
  Items shown surrounded with []'s are optional.
  The label is delimited by one or two
  colon characters (:) and the semicolon (;) delimits the comments. White space
  may be required to delimit the opcode from the operand and multiple
  operands may need either a comma (,) or white space to delimit them from
  one another but otherwise, white space is optional. 
  </p>
  <h3 id="gen_label">Label field</h3>
  <p>
  A label is a user defined symbol that is unique to the first n characters
  (the default is 6, but can be changed to any number up to 32) and is 
  assigned to the value of the current location counter and entered into 
  the user symbol table (as opposed to the 'permanent' symbol table). The 
  value may be either absolute (fixed at a specific location in memory at 
  assembly time) or relocatable (fixed at a specific location at link or 
  load time). This depends on whether the current section is absolute or 
  relocatable. A label is a symbolic method of referring to a specific place
  in memory. If present, a label must be first in the statement and 
  terminated with a colon. For example:
  </p>
  <pre>
      FRED:	LDA FOOBAR
  </pre>
  <p>
  defines FRED to point to the location in memory of the LDA instruction.
  More than one label can appear on a single statement, however, each 
  will be given the same value. For example:
  </p>
  <pre>
      ONE: TWO: THREE: LDA FOOBAR
  </pre>
  <p>
  defines ONE, TWO and THREE to point to the location in memory of the LDA 
  instruction. A symbol used as a label may not be redefined and any 
  attempt to do so will result in an error message. If two colon 
  characters are used to delimit the label, then the label is defined 
  as a global. Global labels are inserted into the object file so that
  LLF and, subsequently, other modules will be able to reference them
  by name. For example:
  </p>
  <pre>
      FRED::	LDA FOOBAR	;fred is defined and also made global
  </pre>
  <p>  
  Internal symbols may belong to the current program section or to other
  program sections. Expressions containing symbols belonging to different
  program sections may not be completely resolved by the assembler.
  Depending on the type of operation that is required in the expression,
  it may not be possible for the assembler to resolve an expression
  regardless of which section a symbol belongs. In these cases, the
  expression will be passed to the separate <b>LLF</b> (custom Link+Locate+Format)
  program to be resolved after all the sections
  have been relocated and labels defined to their ultimate values.
  </p>
  <h3 id="gen_opcode">Opcode field</h3>
  <p>
  The opcode field contains an opcode, macro name or assembler directive
  (pseudo-op). Is is legally terminated by white space or any 
  non-alphanumeric character. For example:
  </p>
  <pre>
      LDA #FRED	;the white space delimits the opcode
      LDA#FRED	;the # delimits the opcode
  </pre>
  <h3 id="gen_operands">Operand field</h3>
  <p>
  The operand field contains zero, one or more items that may be separated
  by commas or white space depending on the requirements of the opcode,
  macro or pseudo-op. The operand field is terminated by the semicolon of
  an optional comment or an end-of-line. For example: 
  </p>
  <pre>
      CLC          ;no operands are required
      LDA FRED     ;FRED is the operand
      LDA FRED,X   ;FRED and X are operands to the LDA opcode
  </pre>
  <h3 id="gen_comments">Comment field</h3>
  <p>
  The comment field is optional and may contain any printing ASCII 
  character as well as tab and space. All other non-printing ASCII 
  characters except new-line will be converted to white space. The 
  comment begins with a semicolon (;) which may appear anywhere on the
  line and continues to end-of-line. The contents of comments are
  ignored by the assembler.
  </p>
  <h3 id="gen_formatting">Formatting</h3>
  <p>
  Spaces, tabs and form feeds may be used at will to control the text 
  formatting in the source file. A form feed character is interpreted as 
  a new line. Except in certain contexts (such as ASCII constants and
  parameter delimiting) white space is ignored by the assembler.
  </p>
  <h4>Symbols</h4>
  <p>
  Assembler symbols, labels and macro names can be comprised of any of the
  letters A through Z (upper and/or lower case), digits 0 through 9,
  period (.), dollar sign ($) and underscore (_). The first character of a
  symbol or label must not be a digit except in the special case of local symbols
  described HERE. The case of the letters in a symbol
  is not significant unless the .ENABL LOWER option has been selected. For
  example: 
  </p>
  <table class="TblCntr" style="width: 20%">
    <tr><th>Valid symbols</th><th>Invalid symbols</th></tr>
    <tr><td>ABC</td><td>0123</td></tr>
    <tr><td>abc</td><td>2abc</td></tr>
    <tr><td>$._AB_C.$$</td><td>9$AB_.</td></tr>
  </table>
  <p>
  The symbol length is, by default, significant to the first 6 characters
  only. The length can, however, be changed via a command line option or
  an assembler directive. In either case the significant length cannot be
  reduced to less than 6 nor made greater then 32. Symbols output in the
  object file will be uppercased (unless the .ENABL LOWER option has been
  selected) and truncated to the significant length. Symbols are delimited
  by any character that is not included in the list of valid symbol
  characters. Be advised that not all load file formats accept symbol names
  as long as 32 characters. Extended TEKhex, for example, will only pass 
  the first 16 characters of a symbol name. This will only be a 
  significant factor if one intends on passing global symbols with long 
  names to a symbolic debugger via a restricting load file format.
  </p>
  <h4>Permanent symbols</h4>
  <p>
  Permanent symbols are those pre-defined in the assembler and consist
  entirely of opcodes and pseudo-ops. The assembler allocates memory from
  the operating system and "seeds" this area with the permanent symbols
  stored internal to the assembler. Macro names that are defined by the
  user are placed into the permanent symbol table perhaps replacing an
  existing entry. 
  </p>
  <h4>User defined symbols</h4>
  <p>
  User symbols both ordinary and local are stored in a user symbol table.
  This symbol table is the only one searched during expression evaluation.
  The permanent symbol table is the only one searched for opcodes.
  Consequently, macro and opcode names may be the same as symbol and label
  names and each represents different values. 
  </p>
  <p>
  User defined symbols are either internal or external (global). All user 
  defined symbols are internal unless explicitly declared otherwise.
  </p>
  <p>
  <b>MAC68K</b> and <b>MACAS</b> have predefined user symbols representing the standard 
  register names found in those processors. See the appendix for specifics.
  </p>
  <h4 id="gen_localSymbols">Local symbols</h4>
  <p>
  There's a special type of symbol known as a local symbol. This symbol 
  is a string of decimal digits terminated with a dollar sign. Its 
  presence is known only within what is known as a local symbol block (LSB).
  The LSB is delimited, unless otherwise indicated, with
  changes in program sections or by the definition of a new label.
  Local symbols can be used anywhere ordinary symbols can be used and are
  defined the same as ordinary symbols. They cannot, however, be declared
  global. Local symbols must consist only of the digits 0-9 and a 
  trailing dollar sign, but otherwise they are treated as ordinary strings 
  and are limited in length to the maximum input size of 255 characters.
  Some examples:
  </p>
  <pre>
      lsb_1:       ;Any label starts a new local symbol block
      10$:         ;defines local symbol 10$
      20$ = fred   ;direct assignments work too,...
      LABEL = fred ;  ...however, direct assignments do NOT open a new LSB
      30$:         ;another local label
      lsb_2:       ;Opens a new LSB
      10$:         ;these local symbols are not the same as
      20$:         ;  the other ones because they are in a
      30$:         ;    different LSB.
      .PSECT       ;this opens a new local symbol block too
  </pre>
  <p>
  There may be instances where one needs to reference local symbols 
  across ordinary labels or through program section changes. This can be 
  accomplished with a pseudo-op:
  </p>
  <pre>
      .ENABL LSB    ;opens a LSB and turns OFF
                    ; the normal lsb delimiter sensing.
      10$:          ;defines a local symbol
      LABEL:        ;in this case, does NOT open a new lsb
      .WORD 10$     ;refers to the 10$ above LABEL
      .DSABL LSB    ;closes the LSB and turns back ON
                    ;  then normal lsb delimiter sensing.
  </pre>
  <h4>Location counter symbol</h4>
  <p>
  There's a special pre-defined symbol, period (.), that refers to
  the current location counter. The value of this symbol is always defined
  and may be relocatable or absolute depending on the attribute of the
  current section. The period may not be used as a label. It may only be
  used in expressions and as the target of a direct assignment statement. 
  For example:
  </p>
  <pre>
      saved_place = .     ;saves current location
      . = some_new_place  ;set the current location to new place
      offset = <.+3>/4    ;compute displacement
  </pre>
  <p>
  Care must be used when making direct assignments to the location counter 
  or there will certainly be unexpected results. For example, there are 
  times when one wants to position the location counter to a fixed 
  location from the beginning of a RELOCATABLE program section. This 
  CANNOT be done by simply assigning the location counter to the offset.
  Suppose one wants to set the location counter to an offset of 1000 from 
  the start of section DATA. First a symbol would have to be defined at
  the beginning of the DATA section:
  </p>
  <pre>
    .PSECT DATA             ;declare section DATA
    START_OF_DATA:          ;define first location of section DATA
  </pre>
  <p>  
  Then the location counter can be set:
  </p>
  <pre>
    . = START_OF_DATA+1000   ;move PC to DATA+1000.
  </pre>
  <p>  
  The more direct approach of .=1000 is only allowed when the current
  location is an absolute (non-relocatable) section. Direct assignments
  that would result in having the current section change are not allowed
  and will result in an error message. For example:
  </p>
  <pre>
      .PSECT TEXT
      FRED:
      .PSECT DATA
      . = FRED	;will result in an error since FRED
                ;   is not in the DATA psect
  </pre>
  </p>  
  <!-- Does not work
  <h4>Symbol blocks</h4>
  <p>
  Another form of local symbol block exists which allows for all forms of 
  symbols to appear "local to the block". That is, symbols and labels
  defined within a symbol block can only be referenced by code and data 
  appearing within that block or a fully enclosed block. These blocks can 
  be nested to a depth of 7. Nested levels beyond 7 are folded into 
  level 7 and a warning message stating that the scoping is too deep is 
  displayed. Inner blocks may reference symbols and labels defined in an 
  outer block, but outer blocks may not reference symbols and labels 
  defined in inner blocks. The outer most level is 0 and is the level 
  used by normal symbols and labels. There are a maximum of 8192 blocks 
  available in a single assembly module. This block is delimited between
        the psuedo ops .PROC and .ENDP. For example:
  </p>
        <pre>
          .PROC        ;This opens a local symbol block
          FRED:        ;This defines a local version of FRED
          FOOBAR = 123 ;It works for both labels and symbols
          .WORD FRED   ;The symbol can be used in the block
          .ENDP
          .WORD FRED   ;This will produce an error since FRED is unknown
          .WORD FOOBAR ;This will error out too
        </pre>
  <p>
  WHEN USING SYMBOL BLOCKS, FORWARD REFERENCES TO SYMBOLS OR LABELS ARE
  NOT ALLOWED. All symbols and labels referenced in the current block must
  be predefined or predeclared. There is a .LOCAL directive to declare a
  symbol and/or label in a block if it is referenced before it is defined. 
  </p>
  -->
  <h4>Radix</h4>
  <p>
  The programmer can specify the radix with which a number is to be
  interpreted on each number appearing in the source or globally for all
  numbers appearing in the source. The radix values can be one of 2,8,10
  or 16. Using the .RADIX pseudo-op specifies which radix to use for all
  numbers appearing between that directive and the next .RADIX or end of
  file. The unary operators ^B, ^O, ^D (or trailing period), ^X or ^H
  can be used on individual numbers to indicate the radices 2, 8, 10, 16
  or 16 respectively. In addition, hexadecimal numbers may be expressed by
  prefixing a "0x" or "0X" to them. 
  </p>
  <h4>Numbers</h4>
  <p>
  Number constants are strings consisting of the digits 0-9 and the
  letters A-F. The first character of the number must be a digit 0-9
  regardless of the current radix. Any character not of that character set
  delimits the number. If the number contains digits that are greater than
  the current radix allows, the assembler will attempt to evaluate the
  number at the appropriate higher radix and displays an error message. A
  temporary decimal radix can be set by appending a period to the number
  or any other temporary radix can be set via a one of the unary operators
  (^B, ^D, ^O, ^X or ^H for binary, decimal, octal, hex or hex respectively).
  For example: 
  </p>
        <pre>
      0110     ;valid binary, octal, decimal or hex number
      1234     ;valid octal, decimal or hexadecimal number
      7890     ;valid decimal or hexadecimal number
      0FFF     ;valid hex number
      A000     ;not a valid number (valid symbol, though)
      1000.    ;decimal 1000
      0x1234   ;hexadecimal number
      ^X 1234  ;hexadecimal number
        </pre>
  
  <h3 id="gen_expressions">Expressions</h3>
  <p>
  An expression is a collection of one or more terms separated by
  arithmetic operators. There are both unary operators (apply only to a
  single term) and binary operators (apply to two terms). Unlike most
  other languages, all operators have equal precedence and are evaluated
  from left to right. The order of evaluation can be changed by the use of
  the parenthesis. (In MAC65, the parenthesis must be substituted with the
  expression brackets "<" and ">"). All terms in an expression and the
  result of the expression itself are 32 bits (signed). The relational
  operators (not available in MAC65) return either a 0 for false or 1 for
  true. 
  </p>
  <table style="width: 30%">
    <tr><th>Binary operators</th><th>Examples</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+</td><td>A+B A added with B (can also be +A which means 0+A)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-</td><td>A-B A subtracted with B (can also be -A which means 0-A)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*</td><td>A*B A multiplied by B (32 bit product)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</td><td>A/B A divided by B (returns a 32 bit quotient)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&</td><td>A&B A logically anded with B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td><td>A|B A logically or'ed with B</td></tr>
  </table>
  <p>    
  The following are <u><b>NOT</b></u> available in MAC65:
  </p>
  <table style="width: 30%"> 
    <tr><th>Binary operators</th><th>Examples</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</td><td>A^B A exclusive or'ed with B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;</td><td>A&lt;&lt;B A shifted B bits left</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;</td><td>A&gt;&gt;B A shifted B bits right</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==</td><td>A==B returns 1 if A equals B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!=</td><td>A!=B	returns 1 if A not equal B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;</td><td>A&gt;B	returns 1 if A greater than B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;</td><td>A&lt;B	returns 1 if A less than B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;=</td><td>A&gt;=B 1 if A greater than or equal to B</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;=</td><td>A&lt;=B	1 if A less than or equal to B</td></tr>
  </table>
  <p>
  The following are available <u><b>ONLY</b></u> in MAC65 (this was chosen to keep compatible with the syntax of the very old PDP11 version of MAC65):
  </p>
  <table style="width: 30%">
    <tr><th>Binary operators</th><th>Examples</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!</td><td>A!B	A logically or'ed with B (same as |)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?</td><td>A?B A exclusive or'ed with B (same as ^ in other assemblers)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</td><td>A{B	A is shifted B bits left (same as &lt;&lt; in other assemblers)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</td><td>A}B	A is shifted B bits right (same as &gt;&gt; in other assemblers)</td></tr>
  </table>
  <p>
  Unary operators are escaped with a circumflex (^) which means the character 
  following the circumflex is the operator. In order for this to be noticed and not confused with the exclusive or
    binary operator, the circumlex must appear as the first character of a term. But one would be wise to watch
    for any potential confusion in this regard. I.E. A^^^B looks confusing, but it means exclusive or A with the high
    byte of B.
  </p>
  <table style="width: 30%">
    <tr><th>Unary operators</th><th>Examples</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^C</td><td>^C A returns 1's compliment of A</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^B</td><td>^B 100 = change radix of term to  2 (binary; number is 0x004)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^D</td><td>^D 100 = change radix of term to 10 (decimal; number is 0x064)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^H</td><td>^H 100 = change radix of term to 16 (hexadecimal; number is 0x100)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^O</td><td>^O 100 = change radix of term to  8 (octal; number is 0x40)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^X</td><td>^X 100 = change radix of term to 16 (hexadecimal; number is 0x100)</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^V</td><td>^V A returns low byte: bits 7-0 of A</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^</td><td>^^ A returns high byte: bits 15-8 of A</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^~</td><td>^~ A returns bits 15:8 swapped with bits 7:0 and bits 23-16 with bits 31-24 of A</td></tr>
  </table>  
    <p>
  Any term of an expression may be enclosed in a pair of expression
  brackets ('&lt;' and '%gt;' in MAC65 or '(' and ')' in all other assemblers)
  and itself be a collection of one or more terms. For example: 
  </p>
    <pre>
      A+&lt;&lt;B*C/D+6&gt;*100&gt;/4?^V&lt;FRED*10&gt;+^H&lt;0FFF+ABC+1234&gt; ;MAC65
      A+((B*C/D+6)*100)/4^^V(FRED*10)+^H(0FFF+ABC+1234) ;others
    </pre>
  <p>
  would evaluate in the following order (left to right, all operators having
  equal precedence):
  </p>
    <pre>
      B*C/D+6*100+A/4 exclusive OR'd with the low byte of FRED*10
      and the whole result added to ABC+(hex)2233
    </pre>
  
  <h4>Direct assignment</h4>
  <p>
  A direct assignment statement associates a symbol with a value (or an
  expression). When a direct assignment statement is used for the first 
  time that symbol is entered into the user defined symbol table and the 
  specified value is attached to it. If the expression does not resolve 
  to an absolute value, then the expression is attached to the symbol. A 
  symbol may be re-defined by assigning a new value to it. The latest 
  assigned value replaces any previous value assigned to the symbol.
  The general format is:
  </p>
    <pre>
      symbol = expression	;comments
    </pre>
  <p>  
  Symbols take on the relocatable or absolute attributes of their defining
  expression. If the expression does not resolve to a single term then the
  resultant expression is attached to the symbol and the value of the
  symbol becomes a multiple term expression which will be substituted in
  whatever other expressions the symbol is used and, in fact, may be
  passed on to LLF if it cannot be resolved during object file creation. A
  double equal sign will declare the symbol global as well as defining it,
  however, for purposes of linking, only the last assignment made to a
  symbol is passed to LLF (i.e. the value at the end of pass one of the
  assembler is what gets passed to LLF). One may prefix a colon to the
  equals or double equals to indicate that the symbol is to be defined
  only once (i.e. generate an error if the symbol is redefined elsewhere).
  For example: 
  </p>
    <pre>
      A = 1      ;A has absolute value of 1
      B:         ;defines B as a relocatable
      C = B      ;C is equivalent to B
      D = E+F+G  ;If E, F or G is undefined or relocatable then
                 ;  D becomes defined as E+F+G (expression)
      H == 12    ;H is global 12
      . = .+100  ;move the location counter up 100 bytes
      J := 10    ;make J an absolute 10 and not eligible for 
                 ;  redefinition
    </pre>
  <p>
    <b>DO NOT MAKE CIRCULAR ASSIGNMENTS SUCH AS</b>
    </p>
    <pre>
        A = B
        B = C
        C = A
    </pre>
  
  <h4>Register symbols and expressions</h4>
  <p>
  Some assemblers (such as MAC11, MACAS, MAC68K, MAC682K) may have opcodes that allow
  or require registers as operands. They may, in fact, sense the type of
  operand and output object data differently based on whether there is a
  register referenced in the operand. Any valid expression term with a
  leading percent sign (%) declares that term as a register (for example
  %5 means register 5). Symbols can be defined as being register
  designators by assigning them to an expression with one or more of the
  terms being a register term. The symbol will inherit the register
  attribute from the expression. For example: 
  </p>
    <pre>
      R0 = %0       ;general register 0
      R10 = %10.    ;general register 10
      TEMP = R0     ;symbol TEMP becomes equivalent to R0
      GR11 == %11.  ;global general register 11
    </pre>
  <p>
  Register symbols can be global and can even be defined in other modules.
  Global register symbols used but not defined in a given module must be
  declared with the .GLOBR pseudo-op. The register attribute of a symbol
  is only significant during the operand processing of an opcode. The
  register attribute of a symbol is not significant in any other assembler
  expression. The register attribute is ignored in MAC65. Undefined registers
  are not allowed in MAC68K. See the appendix for a list of pre-defined
  register symbols for the assembler you are using. 
    </p>
  <h2>Assembler Directives</h2>
  <p>  
  Assembler directives, aka pseudo-ops, are statements that the 
  assembler intreprets as commands to itself. Directives control various 
  aspects of the assembler behavior and output.
    </p>
  <h3 id="dir_align">.ALIGN</h3>
    <pre>
    .ALIGN [expression]
    </pre>
    <p>
  where expression must resolve to an absolute between the values 0 and 31
  inclusive (defaults to 0 or, in effect, a nop). The value of expression becomes an exponent of 2 and the location
  counter is adjusted to the next multiple of the result. The alignment
  attributes of the current program section must enforce an alignment at least
  as great as the one requested or a warning message will be displayed.
  If the alignment attributes of the current section do not enforce an
  alignment as great as the one requested, then do not expect the resultant
  location after linking (LLF) to be correct. Some examples:
  </p>
    <pre>
      .ALIGN 3    ;aligns to next multiple of 8 bytes
      .ALIGN 0    ;aligns to next byte (effectively a nop)
      .ALIGN 1    ;aligns to 2 byte boundary
      .ALIGN fred ;aligns to whatever FRED resolves to
    </pre>
  <h3 id="dir_ascii">.ASCII, .ASCIIZ and .ASCIN</h3>
    <pre>
      .ASCII [string]
      .ASCIN [string]
      .ASCIZ [string]
    </pre>
  <p>  
  Deposits a string of ASCII characters beginning at the current location.
  The parameter string consists of a string of ASCII characters delimited
  by a pair of ASCII characters. The first character in the string is assumed
  the delimiter for the string. The delimiters are not considered part of the
  string so are not inserted into the output file. Any printing character can
  be a delimiter. Expressions can be inserted in the middle of the string by
  delimiting the string and enclosing the expression in matching expression
  brackets (&lt;&gt;'s in MAC65, ()'s in the other assemblers). Ths general 
  format is:
  </p>
    <pre>
      .ASCII string	;Straight ASCII string
      .ASCIN string	;The last byte of the string has bit 7 set
      .ASCIZ string	;An extra byte of 0 is inserted at the end
                    ;    of the string
    </pre>
  <p>
  Some examples:
  </p>
    <pre>
      .ASCII /123/	;puts (hex) 31 32 33 beginning at the current location
      .ASCIN /123/	;puts (hex) 31 32 B3
      .ASCIZ /123/	;puts (hex) 31 32 33 00
      .ASCII \123\&lt;some_expression&gt;/456/	;puts 31 32 33 xx 34 35 36
          ;second set of delimiters doesn't have to match the
          ; first set of delimiters.
    </pre>
  <h3 id="dir_asect">.ASECT</h3>
    <pre>
      .ASECT
    </pre>
  <p>  
  This directive sets the current program section to the default absolute
  section and sets the location counter to the value that was last used in
  that section. It is equivalent to:
  </p>
    <pre>
      .PSECT .ABS.
    </pre>
  <p>  
  See the <a href="#dir_psect">.PSECT</a> directive for more details.
    </p>
  <h3 id="dir_blkx">.BLKx and DS.x</h3>
  <pre>
      .BLKB	expression	;allocates bytes (expression*1)
      .BLKW	expression	;allocates words (expression*2)
      .BLKL	expression	;allocates longs (expression*4)
      .BLKQ	expression	;allocates quads (expression*8)
      DS.B	expression	;(identical to .BLKB)
      DS.W	expression	;(identical to .BLKW)
      DS.L	expression	;(identical to .BLKL)
  </pre>
    <p>
  These directives allocate space in the current program section. They move the
  location counter by the specified number of elements. The expression
  must be absolute but does not have to be positive (a negative value will
  move the location counter backwards). The .BLKW, .BLKL and .BLKQ
  directives will also verify that the current location is aligned
  correctly as indicated by the current section alignment attributes.
  Examples: 
  </p>  
    <pre>
      .BLKB	100		;reserve 100 bytes
      .BLKL	200		;reserve 200 longwords (800 bytes)
    </pre>
  <h3 id="dir_bsect">.BSECT</h3>
  <pre>
    .BSECT
  </pre>
    <p>
  An obsolete directive. See <a href="#dir_psect">.PSECT</a> for details.
    </p>
  <h3 id="dir_byte">.BYTE, .WORD, .LONG and DC.x</h3>
    <pre>
      .BYTE [expression[, expression [, ...]]]
      .WORD [expression[, expression [, ...]]]
      .LONG [expression[, expression [, ...]]]
      DC.B	(same as .BYTE)
      DC.W	(same as .WORD)
      DC.L	(same as .LONG)
    </pre>
    <p>
  All of the above directives have the same syntax. There can be 0 or more
  expressions separated by any construct that is not a valid expression
  term such as a comma or two terms not joined with an expression
  operator. Each expression is inserted in the object code at the next
  higher location. The location counter is verified to have the correct
  alignment according to those specified in the current program section.
  The .BYTE directive places 1 or more bytes in the object file. The .WORD
  directive places one or more 16 bit words in the object file. The .LONG
  directive places one or more 32 bit longwords in the object file.
  Some examples: 
  </p>
    <pre>
      .BYTE                   ;no expression means insert a 0
      .BYTE 1,2,3             ;puts a (hex) 01 02 03 in the output file
      .WORD one two three     ;puts 3 words (6 bytes) in the object file
      .LONG fred + sam foobar ;This puts 2 longs into the output file 
                              ;because fred + sam is a legal expression
                              ;with or without the whitespace. As a result
                              ;the first longword output would be the 
                              ;expression fred+sam and the second longword
                              ;would be the expression foobar.
      .BYTE fred '+ sam foobar ;puts 4 expressions into the output file.
                              ;the '+ is not a valid operator to join two
                              ;terms, so it is assumed to be a term of its
                              ;own. As a result, four expressions are output:
                              ;fred, '+ (hex 2B), sam and foobar.
    </pre>
  <h3 id="dir_csect">.CSECT</h3>
  <p>
    An obsolete directive. See <a href="#dir_psect">.PSECT</a> for details.
    </p>
  <h3 id="dir_define">.DEFINE</h3>
  <p>
  The .DEFINE directive allows for the assignment of an arbirtary string
  to a single assembler symbol. Everywhere in the source between the
  .DEFINE and an .UNDEFINE where the symbol appears, the string will be 
  substituted. It works similar to a #define in the C language. The
  general form is:
  </p>
    <pre>
      .DEFINE symbol an_arbitrary_string [;comments]
    </pre>
  <p>
  where symbol is the name of the symbol which is to be substituted and
  "an_arbitrary_string" is any string of printable characters up to but 
  not including the semicolon delimiting any comments. White space 
  between the symbol name and the string as well as white space between 
  the last character of the string and the comment is not included in the 
  string. Only one level of substitution is performed, that is to say no
  tokens on a .DEFINE or .UNDEFINE directive will be substituted with 
  previously .DEFINE'd symbols. Once a symbol is substituted, the text 
  that has been substituted is not checked for further substitutions.
  Token substitution can take place embedded in strings if the token in
  question is surrounded with apostrophes (the same rules as an argument
  in a macro). Inside macro calls .DEFINEd tokens are replaced after all
  macro arguments are inserted. 
  </p>
    <p>
  Having one or more .DEFINE'd symbols will have an adverse effect on the
  assembler's performance. It is better used in small sections of source
  code (such as during macro definitions), since a symbol can be
  .UNDEFINE'd which will restore the assembler's performance. Examples:
  </p>
    <pre>
        .define fred any string of chars up to a semicolon
        .define foo  a+b		;defines foo
    </pre>
  <p>  
  will force all subsequent occurrences of "fred" in the source file to be
  replaced with the text "any string of chars up to a semicolon" and foo
  to be replaced with the string "a+b". 
  </p>
    <p>
  Note that the text appearing in the list file will be that with all
  tokens substituted. If the resulting assembly of the line produces
  errors, then the original source line will be output to stderr
  (SYS$ERROR) along with the error message but without the line with the
  circumflex (^).
    </p>
  <h3 id="dir_enabl">.DSABL and .ENABL</h3>
  <pre>
  .DSABL arg[,...]
  .ENABL arg[,...]
  </pre>
    <p>
  Many of the states and operational characteristics that MACxx provides can be
  enabled or disabled by way of one of these directives.
  The directive .ENABL enables the function(s) and .DSABL disables the function(s).
  The supplied arguments may be one or more the following keywords:
  </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Function</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;ABS</td><td>Obsolete. Has no effect.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;LC</td><td>Obsolete. Has no effect.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;LSB</td><td>Control local symbol block. <a href="#gen_localSymbols">DETAILS</a></td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;USD</td><td>Causes all divides in both local and global expressions
      to be computed using unsigned arithmetic (UnSigned Divide).</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;GBL</td><td>Causes all undefined symbols to automatically be declared
      global. Use with care. </td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;WORD</td><td>Undefined opcodes are assumed to be arguments to a .WORD directive.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;.WORD</td><td>Same as WORD above.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;M68</td><td>Causes words and longs to be output big endian.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;LOWER_CASE</td><td>Makes all symbols and labels case sensitive.</td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;DOLLAR_HEX</td><td>allows hexadecimal constants to be expressed Motorola style ($?=&gt;0x?)</td></tr>
    </table>
    <p>
  The following keywords are specific to MAC65 and the 6502 processor.
    </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Function</th></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;MOS</td><td>MOS TECHNOLOGY 6502 opcode and address mode syntax. <a href="#M65_Addressing">DETAILS</a></td></tr>
    <tr><td>&nbsp;&nbsp;&nbsp;AMA</td><td>MAC65 is to use zero page addressing if possible.</td></tr>
  </table>
    <p>
    The defaults for all options is DISABLed except for M68 which is ENABLed on MAC68k and MAC682k.
    </p>
  </p>
  <p>
  Some examples:
  </p>
    <pre>
      .ENABL MOS,AMA,USD
      .DSABL WORD,GBL
      .ENABL LSB
    </pre>
  <h3 id="dir_end">.END</h3>
  <p>
  Declares the logical end of assembly and an optional transfer address.
  </p>
    <pre>
      .END [transfer_address]
    </pre>
  <p>  
  The transfer address, if present, must be an expression that resolves to
  a single term that must be defined but can be relocatable. If no transfer address is defined,
  no transfer address will be delivered to LLF. Except for the
  transfer address argument, the directive is ignored by MACxx and
  assembly continues until end of file. The directive is not required. 
    </p>
  <h3 id="dir_endc">.ENDC</h3>
    <pre>
      .ENDC
    </pre>
  <p>
  Declares the end of a conditional block. There must be exactly one 
  matching .IF directive preceding this directive. An error will be
  displayed if a .ENDC directive is encountered outside a conditional 
  block or if a conditional block is opened and not closed with a .ENDC 
  before an end of file is detected. No arguments are required or allowed 
  on this directive.
    </p>
  <h3 id="dir_endm">.ENDM and .ENDR</h3>
    <pre>
      .ENDM [macro_name]
      .ENDR
    </pre>
    <p>
  Declare the end of a macro block. The two directives are identical but
  the .ENDM is typically used to close a .MACRO block and the .ENDR is
  used to close a repeat block (one of .REPT, .IRP or .IRPC). Either
  directive accepts a single argument which, if present, is compared
  against the name of the macro for which it belongs. If the names don't
  match, an error message will be displayed. Repeat blocks are not named
  so no argument should be used on a .ENDR that closes a repeat block.
    </p>
  <h3 id="dir_error">.ERROR</h3>
  <pre>
      .ERROR [[expression] [;comments]]
  </pre>
  <p>  
  This directive generates an error and computes and displays the value 
  of the optional expression. It is useful if included in macros or 
  conditionals to force an error if desired conditions are not met.
  Being that it generates an error, the whole statement will be displayed
  in the list file and on standard error, so the comments can best be
  used to describe the reason for the error.
    </p>
  <h3 id="dir_escape">.ESCAPE</h3>
  <pre>
    .ESCAPE keyword=expression[,...]
  </pre>
    <p>
  This directive allows the changing of various escape characters. 
  Currently the only characters that can be changed are the macro escape 
  characters. Keyword is one of the strings itemized below and expression is an 
  absolute expression that resolves to a printing but non-alphanumeric 
  character. 
  </p>
  <table style="width: 30%">
    <tr><th>Keyword</th><th>Default</th><th>Function</th></tr>
    <tr><td>MACRO_OPEN</td><td>'&lt;</td><td>Start of macro argument</td></tr>
    <tr><td>MACRO_CLOSE</td><td>'&gt;</td><td>End of macro argument</td></tr>
    <tr><td>MACRO_ESCAPE</td><td>'^</td><td>Alternate macro argument delimiter</td></tr>
    <tr><td>MACRO_GENSYM</td><td>'?</td><td>Indicates macro argument is autogenerated</td></tr>
    <tr><td>MACRO_GENVAL</td><td>'\</td><td>Convert macro argument to ASCII</td></tr>
  </table>
  <h3 id="dir_even">.EVEN and .ODD</h3>
  <pre>
    .EVEN
    .ODD
  </pre>
    <p>
  These directives force the current location counter to the next higher
  even or odd value respectively. Note that the PSECT attributes of the current program
  section must enforce a section alignment of at least 1 (word alignment)
  in order for this directive to really do what is desired. If the psect
  attributes do not enforce at least a word alignment, then the section
  may not be located on an even or odd address by LLF. If that happens, the
    effect of the .EVEN will become .ODD and visa-versa. A warning will be displayed by
  the assembler if this condition is present. This directive neither 
  requires nor accepts any arguments. See <a href="#dir_align">.ALIGN</a> and
    <a href="#dir_psect">.PSECT</a> for additional alignment options.
    </p>
  <h3 id="dir_globl">.GLOBL, .GLOBB, .GLOBS and .GLOBR</h3>
  <pre>  
      .GLOBx symbol_1[,symbol_2,...]
  </pre>
  <p>  
  These directives declare one or more symbols or labels as being global
  in scope. That is the listed symbols or labels are made known to
  LLF. The symbols or labels may or may not be defined when this directive
    is issued. If they are not defined anywhere in the source code, then they will be assumed to be
  defined in another module or explicitly by LLF. The .GLOBL directive is
  the general case for declaring ordinary symbols or labels as global in
  scope. The .GLOBR directive declares the symbols as being both global in
  scope and of type register (same as .GLOBL in MAC65). The .GLOBB
  directive declares the symbols or labels as being resident in base page
  (zero page), and at present is only significant to MAC65. The .GLOBS
  directive identifies labels and symbols as accessible via "short" (i.e.
  16 bit offset) address modes in MAC68K (the directive is identical to a
  .GLOBB). Any number of symbols may be listed separated with white space
  or commas. 
    </p>
  <h3 id="dir_if">.IF, .IFF and .IFTF</h3>
    <pre>
      .IF keyword,expression  [;comments]
      .IFF
      .IFT
      .IFTF
    </pre>
  <p>
  This is the general case conditional directive. It opens a conditional
  block which encompasses all the source code between the .IF and a
  matching .ENDC directive. The sense of the conditional can be changed
  with the .IFF (If False), .IFT (If True) and .IFTF (If True or False).
  While the condition is true, the source code is assembled. While the
  condition is false, the source code is examined only for conditional
  directives and otherwise is ignored. The condition is closed when the
  matching .ENDC is encountered. Conditional blocks can be nested to 32
  levels within a single macro level. That is, each level of macro call
  (including the 0th level) has 32 levels of conditional nesting. 
  The keyword determines what type of condition is to be tested.
    For the following keywords, the expression must resolve to an absolute value:
    </p>
  
  <table style="width: 25%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>EQ</td><td>Zero</td></tr>
    <tr><td>NE</td><td>Not zero</td></tr>
    <tr><td>G</td><td>Greater than zero</td></tr>
    <tr><td>GT</td><td>Greater than zero</td></tr>
    <tr><td>GE</td><td>Greater or equal to zero</td></tr>
    <tr><td>L</td><td>Less than zero</td></tr>
    <tr><td>LT</td><td>Less than zero</td></tr>
    <tr><td>LE</td><td>Less than or equal to zero</td></tr>
    <tr><td>NZ</td><td>Not zero (same as NE)</td></tr>
    <tr><td>Z</td><td>Equal to zero (same as EQ)</td></tr>
    <tr><td>T</td><td>Not zero (same as NE)</td></tr>
    <tr><td>F</td><td>Zero (same as EQ)</td></tr>
    <tr><td>EQUAL</td><td>Zero (same as EQ)</td></tr>
    <tr><td>NOT_EQUAL</td><td>Not zero (same as NE)</td></tr>
    <tr><td>GREATER_THAN</td><td>Greater than zero (same as GT)</td></tr>
    <tr><td>GREATER_OR_EQUAL</td><td>Greater or equal to zero (same as GE)</td></tr>
    <tr><td>LESS_THAN</td><td>Less than zero (same as LT)</td></tr>
    <tr><td>LESS_OR_EQUAL</td><td>Less than or equal to zero (same as LE)</td></tr>
    <tr><td>NOT_ZERO</td><td>Not zero (same as NE)</td></tr>
    <tr><td>ZERO</td><td>Zero (same as EQ)</td></tr>
    <tr><td>TRUE</td><td>Not zero (same as T)</td></tr>
    <tr><td>FALSE</td><td>Zero (same as F)</td></tr>
  </table>  
    <p>
  There are three special case .IF's that use something other than an 
  expression to determine the test. These cases are:
  </p>
    <pre>
      .IF keyword,symbol_expression
    </pre>
  <table style="width: 25%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>DF</td><td>Symbol is defined</td></tr>
    <tr><td>NDF</td><td>Symbol is not defined</td></tr>
    <tr><td>DEFINED</td><td>Symbol is defined</td></tr>
    <tr><td>NOT_DEFINED</td><td>Symbol is not defined</td></tr>
  </table>  
    <p>
  In the DF and NDF cases, the symbol_expression may be more than one symbol separated with 
  either a ampersand (&) for AND or a vertical bar (|) for OR (an
  exclamation point (!) in MAC65). For example:
    </p>
    <pre>
       .IF DF, LABEL1 & LABEL2
    </pre>
    <p>
  indicates the condition is true only if both label1 and label2 are
  defined. 
    </p>
    <p>
    The other special condtion test is for blank or not-blank. It follows the syntax:
    </p>
  <pre>
      .IF keyword,string
  </pre>
  
  <table style="width: 25%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>B</td><td>String is blank</td></tr>
    <tr><td>NB</td><td>String is not blank</td></tr>
    <tr><td>BLANK</td><td>String is blank</td></tr>
    <tr><td>NOT_BLANK</td><td>String is not blank</td></tr>
  </table>  
    <p>
    Note that if the string is enclosed in macro argument delimiters
    (normally &lt;&gt;'s) then only the contents between the delimiters is
    tested for blank or not blank. Otherwise, if ANY text appears on
    the line after the comma separating the condition, the "string"
    is considered not blank. This directive only is allowed (or
    useful) inside a macro. 
  </p>
    <p>
    The last special case conditional allows for comparing strings.
    It has the syntax:
    <pre>
      .IF keyword,string1,string2
    </pre>
  
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Condition true if:</th></tr>
    <tr><td>DIF</td><td>String1 is different than string2</td></tr>
    <tr><td>IDN</td><td>String1 is identical to string2</td></tr>
    <tr><td>DIFFERENT</td><td>String1 is different than string2</td></tr>
    <tr><td>IDENTICAL</td><td>String1 is identical to string2</td></tr>
    <tr><td>SAME</td><td>String1 is identical to string2</td></tr>
  </table>  
  <p>  
    Note that string1 and string2 are compared with a simple string
    compare. They must match exactly to be considered identical. If
    either or both of the strings are enclosed in macro argument
    delimiters (normally &lt;&gt;'s), then only the contents between the
    delimters is compared. Some examples:
  </p>
    <pre>
      .IF eq,FRED            ;true if FRED is 0
      .IF GT,LAB1-LAB2*100   ;true if result is greater than 0
      .if ne,LABL-9          ;true if LABL is not 9
      .if NE,FLAGS&100       ;true if bit 8 set in FLAGS
      .if idn,&lt;arg1&gt;,&lt;arg2&gt;  ;true if macro arg1 is same as arg2
      .if ndf,label          ;true if LABEL is not defined
      .if defined, label1 & label2 ;true if both labels are defined
      .if b,&lt;param3&gt;         ;true if macro param 3 blank
      .IF EQ,FLAG            ;open a conditional
      ...some source         ;stuff to do if flag is 0
      .IFF                   ;kinda like an ELSE
      ...some source         ;stuff to do if flag is not 0
      .IFTF
      ...more source         ;stuff to do regardless of flag value
      .IFT
      ...still more          ;stuff to do if flag is 0
      .ENDC                  ;done with conditional
    </pre>
  <h3 id="dir_iif">.IIF</h3>
        <pre>
        .IIF keyword,args,statement [;comments]
        </pre>
  <p>
  This is a special one line conditional (Immediate IF). It has the same
  syntax and rules as the .IF directive above except the single statement to be 
  executed follows the conditional argument(s) separated with a comma.
  See <a href="#dir_if">.IF</a> for details about the conditionals. Examples:
  </p>
  <pre>  
      .IIF NDF,LABEL,LABEL = 100	;define if not already defined
      .IIF EQ,LAB1-10,.error LAB1 	;LAB1 is too big
      .IIF b,&lt;arg5&gt;,.error		;No ARG5 argument supplied
  </pre>

  <h3 id="dir_include">.INCLUDE</h3>
        <pre>
      .INCLUDE filename	[;comments]
        </pre>
  <p>
  This directive allows for additional source files to be included for 
  assembly. Note that the semicolon delimits comments so, on VMS systems anyway, 
  one cannot specify version numbers on filenames. The filename string
  is has the default filetype (.MAC or .mac) appended to it if required and is
  passed otherwise unmodified to the operating system. The filename
  syntax is that of the underlying operating system.
  </p>
  <h3 id="dir_irp">.IRP</h3>
  <pre>
    .IRP dummy_arg,&lt;arg1[[,]arg2[...[,]argn]]&gt;
    macro_body
    .ENDR
  </pre>
    <p>
  The .IRP and .IRPC directives define an indefinite repeat block which is
  simply a macro definition with a single dummy argument (macro <a href="#gen_macros">DETAILS</a>)
  followed with an immediate call. The macro is expanded once for each argument supplied on the
  directive. The macro_body is one or more lines of assembly code to be repeated
  for each argument in the argument list and <b>dummy_arg</b> in the example is the text
  string to be replaced at its each occurance in the macro body. On each iteration of the indefinite
  repeat block, the <b>dummy_arg</b> assumes the value of each successive
  argument in the argument list. Indefinite repeat blocks may be used
  anywhere a macro may be used and is, in fact, a macro definition itself
  with an automatic call at the end of the definition. Arguments in the
  argument list are delimited with white space or commas. Arguments
  containing white space, semicolons and/or commas may be enclosed in
  macro argument delimiters (normally &lt;&gt;'s). There may be no more
  than 125 arguments. Examples: 
  </p>
    <pre>
      .IRP xx,&lt;one,two,three&gt;
      .word xx,xx+1
      fred xx
      .endr
    </pre>
  <p>
  would expand to the following:
  </p>
  <pre>
    .word one,one+1
    fred one
    .word two,two+1
    fred two
    .word three,three+1
    fred three
  </pre>
  <p>
  Another example might be in a general CALL macro where an arbitrary
  number of arguments needs to pushed on a stack, a function called, then
  the arguments purged from the stack. It could be coded something like
  this:
  </p>
  <pre>
    .MACRO CALL FUNCTION ARG_LIST
    ...1 = 0                   ;argument counter
    .IRP ARG,&lt;ARG_LIST&gt;  ;for each argument in the list
    PUSH ARG                   ;push it on the stack
    ...1 = ...1 + 1            ;count it
    .ENDR
    JSR FUNCTION               ;goto function
    ADD #...1,SP               ;adjust the stack
    .ENDM CALL
  </pre>
  <p>  
  Then the macro CALL would be envoked like:
  </p>
    <pre>
      CALL DO_IT &lt;FRED,FOOBAR,FUBAR&gt;
    </pre>
  <p>
  A .MEXIT or .REXIT directive causes the macro expansion to skip to the
  end of the repeat block. If additional arguments remain in the list, the
  repeat block is called with the next argument in line. See also <b>.IRPC</b>,
  .MEXIT, .REXIT and .MACRO <a href="#gen_macros">HERE</a>.
    </p>
  <h3 id="dir_irpc">.IRPC</h3>
  <p>
  Identical to the <a href="#dir_irp">.IRP</a> except the dummy argument is successively 
  replaced with each single character in the argument list. The argument list in 
  this instance is treated as a single string delimited with the &lt;&gt;'s.
  Example:
  </p>
    <pre>
      .IRPC xx,&lt;any_string_of_chars&gt;
      .byte ''xx
      .endr
    </pre>
  <p>  
  would expand to a .BYTE directive for each character in the string
  "any_string_of_chars". For example:
  </p>
  <pre>
    .IRPC xx,&lt;123&gt;
    .byte ''xx
    .endr
  </pre>
  <p>Would expand to:</p>
  <pre>
  .byte '1
  .byte '2
  .byte '3
  </pre>
  <p>
     See also .IRP, .MEXIT, .REXIT and .MACRO <a href="#gen_macros">HERE</a>.
  </p>
  <h3 id="dir_length">.LENGTH</h3>
    <pre>
    .LENGTH keyword=n[,...]
    </pre>
  <p>
  The .LENGTH directive sets the significant length of symbols and/or
  opcode/pseudo-op/macro names. It is recommended that the length be
  selected on the command line rather than with this pseudo-op since
  changing the significant number of characters during the assembly
  may make previously defined symbols and/or macros inaccessible.
  </p>
  The <b>keyword</b> may be one of SYMBOL or OPCODE and the <b>n</b>
  in the example above is a value between 6 and 32 inclusive.
  SYMBOL represents the lengths of user defined symbols and labels
  and OPCODE represents the lengths of opcodes, pseudo-ops and macro names.
        For example:
  </p>
  <pre>
  .LENGTH SYMBOL=32,OPCODE=32
  </pre>
  <h3 id="dir_list">.LIST and .NLIST</h3>
    <pre>
      .LIST [arg[,...]]
      .NLIST [arg[,...]]
    </pre>
  <p>  
  Listing control options can be specified via the directives .LIST
  (enable) and .NLIST (disable). The optional argument list
  represents 0, one or more arguments separated by commas. When
  used without arguments, the listing directives alter the listing level
  count. The listing level count causes the listing to be suppressed when
  less than 0, all items to be listed when greater than 0 and individual
  listing item controls operate when the level count equals 0. The listing
  level count is initialized to 0 at the start of the assembly,
  incremented for each .LIST (without an argument) and decremented for
  each .NLIST (without an argument). The allowable arguments, their
  function and the default values are as follows: 
  </p>
  <table style="width: 50%">
    <tr><th>Keyword</th><th>Default</th><th>Function</th></tr>
    <tr><td>BIN</td><td>list</td><td>list/nlist generated binary code</td></tr>
    <tr><td>BEX</td><td>list</td><td>list/nlist generated binary code that overflows a single line</td></tr>
    <tr><td>CND</td><td>no list</td><td>list/nlist the text in unsatisfied conditional blocks.</td></tr>
    <tr><td>COD</td><td>no list</td><td>list/nlist the generated binary code "as stored" in the object file rather than "as used". See <a href="#gen_list_examples">EXAMPLES</a>.</td></tr>
    <tr><td>COM</td><td>list</td><td>list/nlist comments</td></tr>
    <tr><td>LD</td><td>no list</td><td>list/nlist listing directives that have no arguments.</td></tr>
    <tr><td>LOC</td><td>list</td><td>list/nlist the current location counter (pc).</td></tr>
    <tr><td>MC</td><td>list</td><td>list/nlist macro calls.</td></tr>
    <tr><td>MD</td><td>list</td><td>list/nlist macro definitions</td></tr>
    <tr><td>ME</td><td>no list</td><td>list/nlist macro expansions</td></tr>
    <tr><td>MEB</td><td>no list</td><td>list/nlist only lines in macro expansions that generate binary.</td></tr>
    <tr><td>MES</td><td>no list</td><td>list/nlist source on line of macro expansion that generates binary.</td></tr>
    <tr><td>SEQ</td><td>list</td><td>list/nlist the statement sequence number</td></tr>
    <tr><td>SRC</td><td>list</td><td>list/nlist the source code.</td></tr>
    <tr><td>SYM</td><td>list</td><td>list/nlist the symbol table at the end of the assembly listing.</td></tr>
   </table>
    <p>
  There is a special case in the use of MEB and MES which will cause the
  binary generated by a macro to appear on the same line as the macro
  call. This option is selected with the combination of .LIST MEB and
  .NLIST MES.
  </p>
    <p id="gen_list_examples">
  Examples:
  <p>
    <pre>
      .LIST          ;increments the list level. If the count becomes &gt; 0 then all items are listed.
      .LIST MEB      ;list lines in macro expansion that
                     ;   generate code.
      .NLIST MES     ;but don't list the source of the macro
                     ;   expansions.
      .LIST COD		   ;causes the binary to be displayed "as
                     ;   stored" rather than "as used". This
                     ;   option is significant only on little
                     ;   endian machines (6502, ASAP). i.e.:
      .WORD 0x1234   ;binary displayed as 1234 if .NLIST COD
                     ;  "       "      "  3412 if .LIST COD
                     ;  on a little endian machine
      .LIST ME,CND,SRC,SYM	;multiple arguments can be specified
      .NLIST         ;decrements the list level. If the count becomes &lt; 0 then all items are suppressed from listing.
    </pre>
  <h3 id="dir_long">.LONG</h3>
    <pre>
      .LONG [expression[,...]]
      DC.L	(same as .LONG)
    </pre>
  <p>
  See <a href="#dir_byte">.BYTE</a> for details.
    </p>
  <h3 id="dir_macro">.MACRO</h3>
    <pre>
      .MACRO macro_name [[,]dummy_argument_list[,...]]	[;comments]
    </pre>
  <p>
  This is the first statement in a macro definition. Putting a label on a
  .MACRO directive may prove misleading, however, the value assigned to
  the label will be whatever the current location counter is set to (as
  with any other label) without regard to anything in the macro
  definition. Macro definitions do not move the location counter nor do
  they affect the local symbol blocks.
    </p>
    <p>
  The <u>macro_name</u> is the name of the macro which is any legal symbol and is
  what is used to subsequently call the macro. The macro name is inserted
  in the opcode symbol table which is separate and distinct from the user
  symbol table and means the macro name can be the same as a symbol or
  label without conflict. 
  </p>
    <p>
  The <u>dummy_argument_list</u> is zero, one or more legal string symbols which may
  appear anywhere in body of the macro definition. These symbols are only
  significant during the macro definition (i.e. they are simply place
  markers) and as such will not conflict with like named symbols anywhere
  else in the assembly text. The <u>macro_name</u> and <u>dummy_arguments</u> must be
  separated from one another by commas or white space. No syntax checking
  is done on the body of the macro until the macro is later called. Tokens
  appearing in the macro body are separated and inspected to see if they
  match one of the dummy arguments and, if so, replaced with a marker
  indicating an argument number. When the macro is called, the argument(s)
  on the macro call are inserted into the macro body at the appropriate
  places according to the identifying markers. 
  <p>
  See <a href="#gen_macros">MACRO section</a> for details and examples about the use of macros.
    </p>
  <h3 id="dir_mexit">.MEXIT</h3>
    <pre>
      .MEXIT [expression]
      .REXIT
    </pre>
  <p>
  The .MEXIT and .REXIT directives are an implementation of an alternate exit from a
  macro or repeat block. Upon encountering a .MEXIT directive during a
  macro expansion (not during a macro definition), the macro or repeat block after being called is
  immediately terminated as though it were an .ENDM or .ENDR. This is particularly
  useful in complex conditional structures in that it is a functional
  equivalent to a "goto end_of_macro". The <u>expression></u>
  is optional but, if present, must resolve to an absolute
  value and it indicates how many macro levels to exit. The effect of the 
  .MEXIT or .REXIT is different between ordinary macros and repeat blocks. If the 
  expression argument is blank then the behavior is according to the 
  following truth table:
  </p>
  <table style="width: 100%">
    <tr><th>Macro Type</th><th>Action</th></tr>
    <tr><td>Ordinary</td><td>macro is exited</td></tr>
    <tr><td>repeat block</td><td>block is exited and the repeat count is 
        decremented or the next argument selected;
        block will be re-executed if the repeat
        count remains greater than 0 or argument
        list has not been exhausted.</td></tr>
  </table>
    <p>
  If the expression is present and it resolves to a value less than 0 then
  the .MEXIT or .REXIT is ignored. If the expression resolves to a value greater than 0,
  then that value is used as a count of the number of macro levels to exit.
  A repeat block is considered 1 macro level regardless of its count or
  argument list size. Therefore, a ".MEXIT 1" or ".REXIT 1" in a repeat block will exit
  the block and terminate it as though the count reached 0 or the argument
  list had become exhausted. 
  </p>
    <p>
  If the expression resolves to a value of 0 then the exit behaves according
  to the following truth table:
  </p>
  <table style="width: 100%">
    <tr><th>Macro Type</th><th>Action</th></tr>
    <tr><td>Ordinary</td><td>.MEXIT or .REXIT is ignored</td></tr>
    <tr><td>repeat block</td><td>block is exited and the repeat count is 
        reduced or the next argument selected;
        block will be re-executed if the repeat
        count remains greater than 0 or argument
        list has not been exhausted.</td></tr>
  </table>
    <p>
  The current condition levels (as created by .IF/.ENDC directives)
  are saved and reset to 0 when each macro is called. They are restored
  when the macro exits. The condition levels will be restored correctly
  regardless of how many macro levels are exited.
  </p>
    <p>
  Some examples:
  </p>
    <pre>
      .MACRO TST ARG_LIST
      .IF FALSE, expression
      ...
      .ERROR 	;Report some kind of problem
      .MEXIT	;and skip the rest of the macro
      ...
      .ENDC
      ...
      .ENDM
    
      .IRP XX,&lt;ARG_LIST&gt;
      .IF BLANK, &lt;XX&gt;
      .MEXIT	;don't do anything if argument is blank,
        ;but continue with next argument in list
      .ENDC
      ...
      .IF TRUE, expression
      .ERROR	 ;found some kind of problem
      .MEXIT 1 ;so don't continue the repeat block
      .ENDC
      ...
      .ENDR
    
      .MACRO RECURS ARG_LIST
      .IF TRUE, expression
      RECURS NEW_ARG_LIST
      .IFF
      .IF FALSE, expression
      .ERROR	;Maybe something terrible, or the macro did all it
        ;was supposed to do, so...
      .MEXIT 100000	;Bump all the way out to the top level
      .ENDC
      ...
      .ENDC
      .ENDM
    </pre>
  <h3 id="dir_mdelete">.MDELETE</h3>
  <pre>  
      .MDELETE macro_name[,...]
  </pre>
    <p>
  Deletes macros from memory and frees all the memory associated with the
  macro. The <u>macro_name</u> is one or more macro names separated by commas.
    </p>
  <h3 id="dir_narg">.NARG</h3>
    <pre>
      .NARG symbol
    </pre>
  <p>
  Gets the number of arguments passed to a macro. The <u>symbol</u>
  argument is the name of a symbol that is assigned a value equal to 
  the number of arguments in the macro call. If this directive is used 
  outside a macro, the symbol will be assigned a value of 0.
  </p>
  <p>
  The number of arguments in a  .REPT block is always 0. The number of
  arguments in a .IRP or .IRPC can be 0 or 1 but never more than 1. The
  symbol needn't have been used before, but it must be eligible for
  redefinition.
    </p>
  <h3 id="dir_nchr">.NCHR</h3>
  <pre>  
      .NCHR symbol [,] string
  </pre>
    <p>
  Gets the number of characters in a character string and assigns the 
  length to a symbol. The <u>symbol</u> is assigned a value equal to the number of characters in
  string. The string must be enclosed between macro argument delimiters
  (normally &lt;&gt;'s) if the string contains semicolons, leading commas or
  white space. The symbol needn't have been used before, but it must be
  eligible for redefinition. Some examples:
    </p>
    <pre>
      .MACRO ascic string
      .nchr length,&lt;string&gt;
      .byte length
      .ascii \string\
      .endm
    
      ascic &lt;Hello World&gt;
    </pre>
  <h3 id="dir_nlist">.NLIST</h3>
  <p>
  Decrements the listing level or disables certain list options. See 
  <a href="#dir_list">.LIST</a> for details.
  <h3 id="dir_odd">.ODD</h3>
  <pre>
  .ODD
  </pre>
    <p>
  This directive forces the current location counter to the next higher
  odd value. Note that the PSECT attributes of the current program
  section must enforce a section alignment of at least 1 (word alignment)
  in order for this directive to really do what is desired. If the psect
  attributes do not enforce at least a word alignment, then the section
  may not be located on an even address by LLF (which will make the
  effect of the .ODD to become a .EVEN). A warning will be displayed by
  the assembler if this condition is present. This directive neither 
  requires nor accepts any arguments. See <a href="#dir_even">.EVEN</a>
  and <a href="#dir_align">.ALIGN</a> for additional alignment options.
    </p>
  <h3 id="dir_page">.PAGE</h3>
  <pre>
  .PAGE
  </pre>
    <p>
  Inserts a form feed in the listing file. The .PAGE directive itself is 
  not printed. A .PAGE in a macro definition is ignored until the macro 
  is called. The directive requires nor accepts any arguments.
    </p>
  <h3 id="dir_psect">.PSECT</h3>
  <pre>  
    .PSECT name[,argument...]
  </pre>
    <p>
  This directive defines the name and attributes of a program section
  and sets the current location to that section. The <u>name</u> argument
  is the name of the section and the arguments are a list of 0 or 
  more attributes to be assigned to the section. The attributes, their 
  meaning and default values are as follows:
  </p>
    Argument	Meaning
    --------	-------
    ABS		Absolute
    REL		Relocatable
    CON		Concatenate
    OVR		Overlay
    BASE		Base (Zero) page (MAC65 only)
    OUT		Output text to object file
    NOOUT		Don't output text to object file
    RO		Read only section
    RW		Read write section
    DATA=n		Data alignment within section
    SEGMENT=n	Segment alignment
    MAX_LENGTH=n	Maximum length allowed for section
  
  Absolute and relocatable are terms that describe how the section is 
  placed in the target memory by LLF. If the section is absolute, then 
  the text and labels are fixed at a specific memory location by the 
  assembler and as such will be placed in the target memory at that same 
  location. LLF will not "move" or "relocate" the section somewhere else.
  If the section is relocatable, however, then the text and labels are 
  not fixed at a specific memory location at assembly time and enough 
  information is passed through to LLF so it can re-position the section 
  to an appropriate place in the target memory and adjust the values of
  the labels accordingly. A section can be either absolute or relocatable 
  but not both. The default for all assemblers is REL.
  
  Concatenate and overlay are terms that describe how sections having the
  same name are handled by LLF. If a section is declared as CON, LLF will
  collect all sections having that section's name together appending one
  to the other forming one large section the size of which will be the sum
  of the sizes of each of the members. If a section is declared as OVR,
  LLF will collect all sections having that section's name and overlay one
  on top of another creating one section whose size is the size of the
  largest of the member. A section can be either CON or OVR but not both.
  The default for all assemblers is CON. 
  
  A section can be declared as being a BASE page in MAC65. This tells the
  assembler that even though the section might be relocatable, all
  automatic address mode references to labels defined in this section be
  done with zero page addressing mode. The default is not BASE.
  
  A section may declared as a "memory place holder". That is text may be 
  put in the section and labels may be defined in the section, but the 
  assembler shouldn't output the text to the object file. This kind of 
  section might be for some device registers or scratch ram located in 
  the target system memory space. The OUT and NOOUT arguments select 
  whether or not the text is placed in the object file. The default for
  all assemblers is OUT. Label definitions are not affected by this 
  argument. 
  
  A section may be declared as read-only and read-write on some target 
  systems. The RO and RW arguments identify the section as read-only or
  read-write respectively. A section can be only RO or RW but not both.
  The default for all assemblers is RW. This information is not used by 
  the assembler, it is merely passed through to LLF which may choose to 
  ignore it too or pass it through to an image loader.
  
  The text that is placed in a section may have certain alignment 
  constraints. For example, the 680x0 must have words and longwords 
  aligned on even byte boundaries and ASAP must have everything except 
  bytes aligned on longword boundaries. The assembler can notify the 
  programmer if these alignment rules are not followed as well as fixing 
  the alignments when so instructed. In order to do this, the alignment 
  rules must be established ahead of time. This is done with the DATA and
  SEGMENT arguments. Each takes an expression which must resolve to a 
  value between 0 and 31 corresponding to a power of two that represents 
  the alignment. The SEGMENT value is used by LLF to position the entire 
  section on an appropriate boundary and DATA is used by the assembler to 
  position text within the section appropriately. The alignment value for 
  SEGMENT must be greater than or equal to the alignment value for DATA.
  (If not, then LLF could align the section to a boundary which may 
  violate the required DATA alignment). The defaults are as follows:
  MAC65: DATA=0,SEGMENT=0; MAC68K: DATA=1,SEGMENT=1; MACAS: DATA=2,
  SEGMENT=2.
  
  The maximum length to which a section may grow may also be specified.
  The assembler will check that the section does not exceed this limit as
  well as passing the maximum length along to LLF which will use it to
  verify that the length is not exceeded after all like named sections are
  merged together. The argument MAX_LENGTH=n sets this value where n is an
  expression resolving to an absolute value indicating the maximum length
  in bytes of the named section. The default for all assemblers is no
  maximum. Base pages in MAC65 inherit a maximum length of 255. 
  
  The first time a .PSECT directive is encountered with a unique name, it
  creates the named section and sets all the attributes for that section.
  Subsequent occurrences of a .PSECT directive for a given section name
  cannot change any of the attributes. As a result, sections should be
  defined early in the assembly and referenced thereafter with a ".PSECT
  section_name" without any arguments. 
  
  There are two pre-defined sections: .REL. and .ABS. for the "unnamed"
  relocatable section and the absolute section respectively. The location
  counter is initialized to the start of the .REL. section. One can use
  a .PSECT directive with no name or arguments to set the location 
  counter to the unnamed program section or use a .PSECT .REL..
  
  Each section has it own private location counter which is initialized to
  the beginning of the section (offset 0). The location counter is
  incremented as text is placed in the section or otherwise moved with
  pseudo-ops. When a .PSECT directive is encountered, the current location
  counter is saved with the previous section statistics and the location
  counter last used in the new section becomes the current location
  counter. 
  
  LLF will complain if like named psects in different modules don't have
  EXACTLY the same attributes.
  
  Examples:
  
    .PSECT A,ABS,MAX=16	;section A is absolute
    .PSECT R,REL,OVR	;section R is relocatable and overlayed
    .PSECT IMPURE		;defaults to REL,CON,RW
    .PSECT PURE,RO		;make read-only section
    .PSECT PAGE,DATA=3,SEG=9 ;align section to 512 byte, data to 8 byte
    .word test,...		;put in some text
    .PSECT IMPURE		;change sections
    .word text,...		;put text in different section
    .PSECT PAGE		;change back to old section
  
  2.49)	.PUSH
  
  Pushes values of expression(s) to the specified stack. The format is:
  
    .PUSH stack_name [,] expression [,...]
  
  where stack_name is the name of a stack as declared in a previous
  .DEFSTACK directive and expression resolves to a value that is pushed to
  the top of the stack. If the stack is other than a RELATIVE stack, the
  expression must resolve to an absolute value. 
  
  The stack pointer will be pre-decremented by one for each expression
  pushed.
  
  Examples:
  
    .DEFSTACK TEMP,100		;make temp array of longs
    .PUSH TEMP,FRED,100,FOOBAR	;save 100, FRED and FOOBAR 
    
  NOTE: These stack options are not available in recent macxx versions.
  
  2.50)	.PUTPOINTER
  
  Sets the stack pointer of the named stack to a given value. The syntax 
  is:
  
    .PUTPOINTER stack_name,expression
  
  where stack_name is the name of the stack as defined in a .DEFSTACK 
  directive and expression resolves to an absolute value between 0 and 
  the size of the stack in elements. The internal stack pointer takes on 
  the new value if the expression data is valid. Example:
  
    .PUTPOINTER my_stack ,100	;reset stack pointer
  
  NOTE: These stack options are not available in recent macxx versions.
  
  2.51)	.RADIX
  
  Numbers expressed in the assembly source are assumed to be hexadecimal. 
  The global radix can, however, be changed. This is done by:
  
    .RADIX expression
  
  where expression resolves to an absolute value of one of 2, 8, 10 or 16
  for binary, octal, decimal or hexadecimal respectively. The radix is
  temporarily changed to decimal before the expression is evaluated. If
  the expression resolves to an unacceptable value, the global radix is
  not changed. For example: 
  
    .RADIX 10 	;changes radix to decimal regardless of what
          ;it was before
    .RADIX 16	;change radix to hex
  OLD_RADIX = 10		;saves current value of global radix
    .RADIX NEW_VALUE ;set it to a new value
    .RADIX OLD_RADIX ;restore the old value
  
  2.53)	.REPT
  
  The .REPT directive defines an indefinite repeat block, which is simply
  a macro definition with no arguments followed with an immediate and
  automatic macro call (see details about macros in chapter 3). The macro
  is expanded if the count is greater than 0 and the count is decremented
  with each iteration. The syntax of an indefinite repeat block is: 
  
    .REPT count
    macro_body
    .ENDR
  
  where count is an expression that resolves to an absolute value
  representing the number of times the macro_body is to be expanded and
  macro_body is zero or more lines of assembly code constructed with the
  same rules as for a macro definition. Indefinite repeat blocks may be
  used anywhere a macro may be used. The count is tested at the top of 
  each loop and, if greater than 0, the macro_body is executed and the
  count is decremented. A .MEXIT or .REXIT executed in the macro_body
  will force the repeat block to skip to the end. A .MEXIT 1 (or more)
  will force the repeat block to exit completely. Examples: 
  
  tmp = 0
    .REPT 16.
    .byte tmp+0,tmp+1,tmp+2,tmp+3
  tmp = tmp + 4
    .endr
  
  would output 64 bytes (16*4) whose values would range from 0 to 63.
  
  2.540)	.RESTORE
  
  Restores the location counter and local symbol block from a previous 
  .SAVE directive. The general form is:
  
    .RESTORE
  
  See .SAVE for additional details.
  
  2.54)	.REXIT
  
  The .REXIT directive is an implementation of an alternate exit from a
  repeat block (.IRP, .IRPC or .REPT). Upon encountering a .REXIT
  directive during a repeat block expansion (not during a definition), the
  repeat block is immediately terminated as though it were an .ENDR. This
  is particularly useful in complex conditional structures in that it is a
  functional equivalent to a "goto end_of_repeat_block". This directive is
  ignored outside a macro or repeat block. The general form is: 
  
    .REXIT
  
  2.55)	.SAVE
  
  The .SAVE directive saves the current program section context and local 
  symbol block details on an internal stack. The internal stack is 32
  elements deep. This directive can be used whenever one wants to change
  program sections but needs to be able to restore the section without 
  knowing the name of the current section. This is the most useful in
  macros. For example:
  
    .MACRO SAY MSG	;general message macro
    .SAVE		;save the current location counter/section
    .PSECT ASCII	;switch to section ASCII
  ...1 = .		;get location of text message
    .ASCIZ \MSG\	;insert message in the ASCII section
    .RESTORE	;back to main section (whatever that is)
    .PRINT #...1	;display message
    .ENDM
  
    SAY <This is a test of the .SAVE directive> ;say message
  
  The local symbol block is saved as well. Even though a new local symbol
  block would be opened if there's an intervening label or the program
  section is changed, when the .RESTORE is encountered, the original local
  symbol block is also restored. For example: 
  
    10$:			;mark the start
      .SAVE		;save the current loc and lsb
      .PSECT T	;change sections
    10$:			;this is a different lsb, since the
          ;   section changed
      .RESTORE	;restore section
      .WORD 10$	;references the FIRST 10$ since the
          ;   lsb is restored as well as the
          ;      location counter
  
  Beware of .SAVE'ing the current section and not doing a .PSECT to a
  DIFFERENT section before adding code or data then doing a .RESTORE
  since that has the effect of moving the location counter backwards.
  For example:
  
      .PSECT CODE	;say we're in the code section
    FRED:	.SAVE		;save location of FRED
      .PSECT CODE	;this is a no-op since we're already
          ;  in section CODE
      .WORD 1,2,3	;inserting TEXT
      .RESTORE	;resets location counter back to FRED
      .WORD 4,5,6	;will overwrite the 1,2,3 above
  
  2.56)	.SBTTL
    .SUBTITLE
  
  Establishes a string to use as a subtitle which is placed on the second
  line of each page in the listing. The first line of each page in the
  listing file contains the title line. The text is for information only
  and is not used by the assembler. This directive is ignored if no
  listing file is being created. The format is: 
  
    .SBTTL text_of_subtitle_message	[;comments]
  
  2.57)	.TEST
  
  The .TEST directive allows you to pass an expression to LLF to evaluate and
  report an error if the condition is true. If the expression can be evaluated by
  the assembler (i.e. no complex terms) and it evaluates true (true = not zero),
  then the assembler will report the error. This function is much more useful in
  MACAS, MACPP and MAC68K since those assemblers have relational operators (eq,lt,
  gt, etc), however, it is built in to the core assembler so you have it if you
  can use it. The syntax is:
  
      .TEST expression	;message to be reported if expression is true
            ^ note the semicolon is required
  
  where "expression" is the expression to evaluate or pass to LLF and the 
  comments are the text of the error message to be displayed if the 
  expression resolves to TRUE (non-zero). Example:
  
    .GLOBL  TEMP	;declare an external variable
    .TEST !(TEMP>0 && TEMP<0x10) ;PROG: TEMP should be 0-0x0F
  
  In this example since TEMP is a global symbol, the expression will be
  evaluated by LLF. The comment field is the text of the message 
  displayed if the expression evaluates true, so the comment should have 
  meaningful information in it such as the program name and/or variable(s)
  involved, etc.
  
  2.58)	.TITLE
  
  Establishes a string to use as the program title which is placed on the 
  first line of each page in the listing. The text is for information 
  only and is not used by the assembler. This directive is ignored if no
  listing file is being created. The format is: 
  
    .TITLE text_of_title_message	[;comments]
  
  2.585)	.UNDEFINE
  
  The .UNDEFINE directive removes the assignment of a previously 
  .DEFINE'd symbol or, optionally, all previously .DEFINE'd symbols. The 
  general form is:
  
    .UNDEFINE [symbol]
  
  where symbol represents the symbol to undefine. No error is displayed if
  the symbol has not previously been .DEFINED. If no symbol name is
  supplied, then all symbols previously .DEFINE'd will be de-assigned.
  Example:
  
    .DEFINE FRED A+B	;assign string to FRED
    .WORD FRED		;use FRED
    .UNDEFINE FRED		;deassign FRED
    .UNDEFINE 		;deassign all symbols
  
  2.59)	.VCTRS
  
  This is a short cut directive to allow one to insert 16 bit words at a 
  specified non-relocatable location in the target memory. This 
  directive is not recommended for any assembler except MAC65 where it
  may be used in simple applications. It exists mainly to insert the 
  program vector table for the 6502 at 0xFFFx without the overhead of 
  establishing a program section and having LLF position it accordingly.
  The general form is:
  
    .VCTRS address [,] data [, ...]
  
  where address is an expression resolving to an absolute value 
  representing where the first byte of data should be placed and data is 
  0 or more expressions (which may be relocatable) which will placed in 
  the target memory as 16 bit words. The data expressions are interpreted 
  exactly the same as they would be on a .WORD directive. The directive 
  functions as though the following separate statements were executed:
  
    .SAVE		;save current location counter
    .PSECT .ABS.	;switch to the absolute section
    .=address	;set the location counter to the desired value
    .WORD data,...	;insert the data
    .RESTORE	;restore the previous location counter
  
  with the exception that the size of the .ABS. section is not changed to
  reflect the event.
  
  An example:
  
    .VCTRS 0xFFF8,FIRQ,NMI,RESET,IRQ
  
  2.60)	.WARN
  
  This directive generates a warning and computes and displays the value 
  of the optional expression. It is useful if included in macros or 
  conditionals to force a warning if desired conditions are not met.
  Being that it generates a warning, the whole statement will be displayed
  in the list file and on standard error, so the comments can best be
  used to describe the reason for the error. The form is:
  
    .WARN [[expression] [;comments]]
  
  2.61)	.WORD Constant storage directives
    DC.W	(same as .WORD)
  
  Places one or more 16 bit words in the object file.
  
  Syntax:
  
    directive	expression [[,]...]
  
  See .WORD (2.0.6) for additional details.

  <h2 id="gen_macros">Macros</h2>
  
  Macros are a mechanism whereby a user can have several lines of
  assembly code envoked with a single statement. This is done by defining 
  a macro as a series of one or more assembler statements and giving
  the macro a name. The name of the macro is inserted in the opcode
  symbol table so when that name is used as an opcode, the assembler
  will insert the line(s) of code making up the definition into the 
  source sequence. It is similar in concept to an "in-line subroutine". 
  As in a subroutine, the macro system also allows for the passing of
  arguments. When a macro is defined, a list of arguments is identified
  by name each of which will be replaced by a corresponding argument 
  occupying the same relative position on the macro call as on the macro 
  definition. Typically the arguments are treated as strings and inserted 
  into the expanded macro code at the appropriate place(s), however, the 
  argument may also be passed as a value or as an automatically generated 
  symbol. In addition, the arguments may be declared to inherit default 
  values should they be omitted on the macro call and/or the arguments 
  may be set by keyword value rather than by placement.
  
  3.1) Macro definitions
  
  General macros are defined with the .MACRO directive and the special 
  case repeat block macros are defined with the .IRP, .IRPC and .REPT 
  directives. The form of a .MACRO definition is:
  
    .MACRO name [,] dummy_argument_list [;comment]
    macro_body
    .ENDM
  
  where:
  
    name is the name of the macro. It is inserted in the opcode
      symbol table so will be called up when the name is
      used in the opcode field of an assembler statement.
    dummy_argument_list is a list of zero or more legal assembler
      symbols separated with white space or commas which
      may appear anywhere in the macro_body.
    macro_body is any number of assembler statements.
  
  Macro names replace whatever is in the opcode symbol table, so one can
  use macros to redefine opcodes. Deleting a macro that replaced an opcode
  causes the old opcode to be restored.
  
  The symbols appearing in the dummy argument list only mark places in the
  macro_body where the corresponding argument on the macro call should be
  placed. They do not have any relation to other symbols or labels or
  dummy arguments in other macros (unless it's a nested macro definition)
  so do not have to be unique in that respect. You may decide to choose a 
  name for a dummy argument that has something to do with its function 
  which would make it a bit easier to use the "pass argument by keyword"
  feature (described later).
  
  The macro body is checked only for .MACRO, .IRP, .IRPC, .REPT, .ENDR
  and .ENDM directives in the opcode field and the presence of dummy
  arguments anywhere in the macro body. No syntax checking is done at 
  all on any data in the macro until the macro is called. As a result,
  DO NOT use the symbols .MACRO, .ENDM, .ENDR, .REPT, .IRP and .IRPC as
  dummy argument names. 
  
  Macro definitions may be nested. That is to say a macro may be created 
  to create other macros which may create other macros etc. to any depth.
  The inner macros, however, won't be defined until the outer macros are
  called.
  
  3.2) Macro definition argument syntax
  
  Dummy arguments appearing on the .MACRO directive are separated from 
  one another and the macro name by commas or white space.
  
  Dummy arguments appearing in the macro body are delimited by any
  character not legal for a symbol or label. If the dummy argument appears
  embedded within or connected to an otherwise legal symbol or label, it
  will not be recognized as a dummy argument. If one desires to cause the
  argument to be prefixed, appended or inserted in the middle of an
  otherwise legal symbol name, the dummy argument may be separated from
  the non-argument text (of any kind) with an apostrophe. The apostrophe(s)
  will be stripped and the argument substitution will occur with no other
  surrounding characters changed. If an apostrophe is required to remain
  in the substituted text, you will need to have two of them. For example: 
  
    .MACRO TST ARG1
    ARG1			;no apostrophes required
    PRE+ARG1+POST		;here either
    PRE'ARG1'POST		;if called with TST T, expands to PRETPOST
    'ARG1'POST		;leading apostrophe is optional
    PRE'ARG1'		;trailing apostrophe is optional
    ''ARG1'AFTER		;if called with TST T, expands to 'TAFTER
    'FOOBAR'		;apostrophes are only removed when
          ;   surrounding dummy arguments.
          ;   So a TST T expands to 'FOOBAR'.
    .ENDM
  
  There is an optional feature with dummy arguments that instructs the
  assembler to assign a default string to that argument if the macro is
  called with the given argument blank. This is done by putting the
  default string following an equal sign appended to the dummy argument on
  the .MACRO statement. If the default string contains commas or spaces,
  it can be enclosed in macro argument delimiters (normally <>'s). For
  example: 
  
    .MACRO FRED ARG1,ARG2,ARG3=0x1000,ARG4=<1,2,3>
    ARG1 ARG2,ARG3 <ARG4>
    .ENDM
  
  defines the macro FRED with 4 arguments. The dummy arguments ARG1, ARG2,
  ARG3 and ARG4 will be replaced with corresponding arguments when FRED is
  called. If ARG3 is left blank on the call, the string 0x1000 will be
  used. If ARG4 is left blank on the call, the string "1,2,3" will be
  used. Using the above defined macro: 
  
    Call			Expands to
    ---------------------	------------------------
    FRED ONE TWO THREE	ONE TWO,THREE <1,2,3>
    FRED ONE TWO,,FOO	ONE TWO,0x1000 <FOO>
    FRED ONE TWO		ONE TWO,0x1000 <1,2,3>
    FRED ONE		ONE ,0x1000 <1,2,3>
    FRED			,0x1000 <1,2,3>
  
  There is one special type of dummy argument that is identified with a
  leading question mark. This indicates that, when the macro is called and
  the argument is left blank, the dummy argument should be replaced with
  an automatically generated local symbol. These automatically generated
  local symbols are numbered starting with 65000$. Note that the symbol
  does not automatically become a label. You need to use the argument as a
  label somewhere in the macro body in order for the local symbol to
  become a local label. No default value may be assigned to an argument of
  this type. For example: 
  
    .MACRO MAKSYM SOMETHING,?OPT_LABEL
    ...
  OPT_LABEL: 
    SOMETHING
    ...
    .ENDM
  
    Call			Expands to
    --------------		-----------
    MAKSYM FRED		65000$:	FRED
    MAKSYM FOOBAR		65001$:	FOOBAR
    MAKSYM NOP,MY_LABEL	MY_LABEL: NOP
  
  There are a maximum of 124 arguments allowed in a macro definition.
  
  The only pseudo-ops recognized in the macro body are other macro
  definition directives (.MACRO, .IRP, .IRPC and .REPT) and the macro
  termination directives .ENDM and .ENDR. Macro definitions may be nested,
  therefore there must be a matching terminator (.ENDR or .ENDM) for each
  macro definition directive. The outer most termination completes the
  definition. Macros are always stored in memory as are symbols and the
  intermediate object file (if /WORK_FILE is not selected on the command
  line) so they will be limited in size and quantity to the amount of memory
  available to the assembler. If a macro is defined that has the same name
  as a previously defined macro, the old one is deleted from memory and
  replaced with the new one.
  
  3.3) Macro calls
  
  A macro must be defined prior to its first reference. Macro calls are of
  the general form:
  
    [label:]  name [real_arguments]	[;comments]
  
  where:
    "label" represents an optional label.
    "name" represents the name of the macro as specified as the
      first argument on the .MACRO directive
    "real_arguments" are those symbols, expressions, and values
      which replace the dummy arguments as described in the
      .MACRO directive separated by commas or white space.
  
  Arguments to a macro call are treated as character strings whose usage
  is determined by the statements appearing in the macro definition with
  one exception as described below. If white space or commas appear in a
  macro argument, the argument must be enclosed between a pair of macro
  argument delimiters (normally <>'s). For example given the macro FRED:
  
    .MACRO FRED ARG1,ARG2,ARG3=0x1000
    ARG1 ARG2,ARG3
    .ENDM
  
  the call of:
  
    FRED <.WORD ONE,TWO>,THREE,FOUR
  
  expands to
  
    .WORD ONE,TWO THREE,FOUR 
  
  The up-arrow construct may be used to change the argument delimiters
  locally if desired. For example the following is equivalent to the
  example above:
  
    FRED ^\.WORD ONE,TWO\,THREE,FOUR
  
  3.4) Macro call arguments
  
  Arguments on a macro call are separated from other arguments by commas
  or white space. Arguments which contain commas or white space must be
  enclosed in paired macro delimiters (normally <>'s). An up-arrow
  construct may be used to change the delimiter characters on an
  individual argument. This would be useful if the argument contains
  argument delimiter characters itself. For example, given the macro
  definition: 
  
    .MACRO FOO ARG1 ARG2
    ARG1 ARG2
    .ENDM
  
  One could call it with:
  
    FOO <ADD #24,> ANSWER	;or
    FOO ^/ADD #24,/ ANSWER	;the equivalent call
  
  which would expand to:
  
    ADD #24, ANSWER
  
  The macro argument delimiters are removed from the argument as the
  dummy argument substitution is made. As noted above, the <>'s and the
  ^//'s do not appear in the final expansion. This should be particularly
  significant during macro nesting. For example, one could recursively
  call the macro FOO as defined above with:
  
    FOO <FOO <ADD #24,>> ANSWER
  expands to:
    FOO <ADD #24,> ANSWER
  and that expands to:
    ADD #24, ANSWER
  
  Note that with each expansion, one level of <>'s have been removed 
  from  the argument.
  
  Arguments are normally delivered to macros by placement. That is, the
  first argument after the name on a macro call replaces the first dummy
  argument in the macro body. The second replaces the second dummy
  argument, etc. Arguments may also be delivered to a macro in a macro
  call by way of keywords. That is, an argument may be identified by its
  dummy argument name instead of by placement. This is done by prefixing
  the real argument value with the dummy argument name followed by an
  equal sign. All the arguments that are identified by keywords are
  assigned first. Then, if there are any additional arguments, they are
  assigned positionally to any dummy arguments that haven't yet been
  assigned. For example, given the macro definition: 
  
    .MACRO FOOBAR A,B,C,X,Y,Z
    .WORD A,B,C,X,Y,Z
    .ENDM
  
  The macro call:
  
    FOOBAR 1,2,3,4,X=5,A=6
  
  expands to
          _________________ Dummy argument A gets value "6"
          |     ___________ Dummy argument X gets value "5"
          |	    |
          v     v
    .WORD 6,1,2,5,3,4
      ^ ^   ^ ^
      L_L___L_L______ Other arguments get what's left in order
  
  Normally, arguments on a macro call are treated as simple strings and
  substituted for dummy arguments unchanged into the macro body. There is
  one special type of macro call argument which can be used which is a
  pass by value. In this case the argument must be an expression that
  resolves to an absolute value and the expression is must be prefixed
  with a backslash character (\). With this construct, the expression is 
  evaluated and the value is converted to ASCII in the current default radix.
  This ASCII string is what gets substituted for the dummy argument. You 
  may also specify the radix for the conversion by using a double backslash
  followed by one of O, D, H or X for octal, decimal, hexadecimal or 
  hexadecimal respectively. The general syntax is:
  
    macro_call [...args...] \absolute_expression [...args...]
  
  Some examples:
  
    .RADIX 10		;decimal radix
    FRED=400
    .MACRO GENVAL VAL
    .word vtst'val,val
    .endm
  
    Called 			Expands to
    ---------		----------
    GENVAL \FRED*4		.WORD VTST1600,1600
    GENVAL \FRED/2		.WORD VTST200,200
    GENVAL \\XFRED/2	.WORD VTST0C8,0C8
  
  
  
        Chapter 4
  
        Operating Instructions
  
  4.0) This assembler has been ported to and the appropriate version will
  run on VAX/VMS(tm), MS-DOS(tm), SCO Xenix/386(tm), SCO Unix(tm) and
  GEM-DOS (Atari/ST). The command line syntax is the same for all 
  versions with the exception that the option delimiter on Xenix/Unix
  is a dash character (-) instead of the slash character (/). In addition,
  the Xenix/Unix option(s) must be preceeded with white space since the 
  dash is a legitimate filename character. The general form is:
  
    MACxx file(s)... [options...]
  
  where MACxx is the name of the program (MAC65, MAC68K, MACAS or MACPP),
  file(s) represents one or more files separated with whitespace or 
  commas and options represents one of the options itemized below. The 
  options and filenames can appear on the command line in any order.
  Whitespace must separate an option from a filename following it but is 
  otherwise optional except on Xenix/Unix systems where white space must
  separate filenames and options from one another. Commas are treated
  as whitespace.
  
  The valid options are:
  
    Option		Default	Meaning
    --------------	-------	--------------------
    /NOOUTPUT	  No	Don't create an output file
    /OUTPUT		  Yes	Create output object file whose name
            matches the name of the first input
            file with filetype of .OB or .OL.
    /OUTPUT=name		Creates output object file with 
            specified name. Default filetype of
            .OB or .OL.
    /NOLIST		  Yes	Don't create a listing file
    /LIST		  No	Create output listing file whose name
            matches the name of the first input
            file with a filetype of .LIS.
    /LIST=name		Create output listing file with 
            specified name. Default filetype of
            .LIS.
    /CROSS		  No	Do a symbol cross reference report in the
            listing file.
    /NOCROSS	  Yes	Don't do a cross reference report.
    /BINARY		  Yes	Create output object file in binary format.
             Selects default object filetype of .OB.
    /NOBINARY	  No	Create output object file in ASCII format.
             Selects default object filetype of .OL.
    /NOTEMPFILE	  Yes	Use memory to hold intermediate object file.
    /TEMPFILE	  No	Use temporary file to hold intermediate
             object file (only necessary on very small
             systems or with very large source files).
    /TEMPFILE=name		Assigns path/filename for temporary file
             (I.e. ramdisk on MS-DOS system).
    /NOMISER	  No	Don't compress intermediate object file.
             (This may speed up the assembler on
              some systems).
    /MISER		  Yes	Assembler is miserly about using memory.
    /NOCMOS		  Yes	MAC65 only; selects the instruction set for
             the ordinary 6502 processor.
    /CMOS		  No	MAC65 only; selects the instruction set for
             the CMOS version of the 6502.
    /NODEBUG	  Yes	Doesn't put source code debug 
             information in the object file.
    /DEBUG		  No	Places source code debug information in 
             the object file.
    /SYMBOL_LEN=n	  n=6	Sets the significant length of the 
             symbols and labels to n. n may be a
             value between 6 and 32.
    /OPCODE_LEN=n	  n=6	Sets the significant length of the opcodes,
             pseudo-ops and macro names. n may be a
             value between 6 and 32.
  
  NOTE: On Xenix/Unix systems, the slash (/) is replaced with a dash (-).
  
  The case of any option is not significant and they may be abbreviated to
  the least number of characters that prevents ambiguity. 
  
  Examples:
  
    MAC65 FOOBAR/LIS	!outputs are FOOBAR.OB and FOOBAR.LIS 
    MAC65 FUBAR/NOBIN	!output is FUBAR.OL
    MAC65 FUBAR		!output is FUBAR.OB
    mac65 foobar -lis	!on Unix...
    mac65 -lis foobar	!...options can be anywhere
    MACAS HEADER,FOO,BAR/LIS=TEST/OUT=FOO/DEBUG/SYM=16  !...
          !   ...files HEADER, FOO and BAR are
          !   ...assembled in order; the outputs
          !   ...are FOO.OB and TEST.LIS
          !   ...FOO.OB has debug records in it
          !   ...symbol/labels are significant to 16
          !   ...characters.
  </body>
</html>
